<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MaTonna&#39;s blog</title>
  
  <subtitle>关于学习，时间会给你答案</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="github.com/MaTonna/"/>
  <updated>2019-04-25T12:17:09.142Z</updated>
  <id>github.com/MaTonna/</id>
  
  <author>
    <name>MaTonna</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>处理树组件需要的数据结构</title>
    <link href="github.com/MaTonna/2019/04/25/%E5%A4%84%E7%90%86%E6%A0%91%E7%BB%84%E4%BB%B6%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>github.com/MaTonna/2019/04/25/处理树组件需要的数据结构/</id>
    <published>2019-04-25T06:39:50.793Z</published>
    <updated>2019-04-25T12:17:09.142Z</updated>
    
    <content type="html"><![CDATA[<p>基本数据：</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeData = [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">'1'</span>, <span class="attr">parentId</span>: <span class="string">'0'</span>, <span class="attr">name</span>: <span class="string">'KK总部'</span>, <span class="attr">orderNumber</span>: <span class="number">0.0</span>, <span class="attr">hasChild</span>: <span class="literal">true</span>, <span class="attr">enabled</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">'11'</span>, <span class="attr">parentId</span>: <span class="string">'1'</span>, <span class="attr">name</span>: <span class="string">'财务'</span>, <span class="attr">orderNumber</span>: <span class="number">0.0</span>, <span class="attr">hasChild</span>: <span class="literal">true</span>, <span class="attr">enabled</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">'12'</span>, <span class="attr">parentId</span>: <span class="string">'11'</span>, <span class="attr">name</span>: <span class="string">'财务0-1'</span>, <span class="attr">orderNumber</span>: <span class="number">0.0</span>, <span class="attr">hasChild</span>: <span class="literal">false</span>, <span class="attr">enabled</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">'13'</span>, <span class="attr">parentId</span>: <span class="string">'11'</span>, <span class="attr">name</span>: <span class="string">'财务0-2'</span>, <span class="attr">orderNumber</span>: <span class="number">0.0</span>, <span class="attr">hasChild</span>: <span class="literal">false</span>, <span class="attr">enabled</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">'3'</span>, <span class="attr">parentId</span>: <span class="string">'1'</span>, <span class="attr">name</span>: <span class="string">'销售部'</span>, <span class="attr">orderNumber</span>: <span class="number">0.0</span>, <span class="attr">hasChild</span>: <span class="literal">false</span>, <span class="attr">enabled</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">'4'</span>, <span class="attr">parentId</span>: <span class="string">'1'</span>, <span class="attr">name</span>: <span class="string">'客服部'</span>, <span class="attr">orderNumber</span>: <span class="number">0.0</span>, <span class="attr">hasChild</span>: <span class="literal">false</span>, <span class="attr">enabled</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">'5'</span>, <span class="attr">parentId</span>: <span class="string">'1'</span>, <span class="attr">name</span>: <span class="string">'行政部'</span>, <span class="attr">orderNumber</span>: <span class="number">0.0</span>, <span class="attr">hasChild</span>: <span class="literal">false</span>, <span class="attr">enabled</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">'2'</span>, <span class="attr">parentId</span>: <span class="string">'0'</span>, <span class="attr">name</span>: <span class="string">'KK总部1'</span>, <span class="attr">orderNumber</span>: <span class="number">0.0</span>, <span class="attr">hasChild</span>: <span class="literal">true</span>, <span class="attr">enabled</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">'7'</span>, <span class="attr">parentId</span>: <span class="string">'2'</span>, <span class="attr">name</span>: <span class="string">'财务1'</span>, <span class="attr">orderNumber</span>: <span class="number">0.0</span>, <span class="attr">hasChild</span>: <span class="literal">false</span>, <span class="attr">enabled</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">'8'</span>, <span class="attr">parentId</span>: <span class="string">'2'</span>, <span class="attr">name</span>: <span class="string">'销售部1'</span>, <span class="attr">orderNumber</span>: <span class="number">0.0</span>, <span class="attr">hasChild</span>: <span class="literal">false</span>, <span class="attr">enabled</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">'9'</span>, <span class="attr">parentId</span>: <span class="string">'2'</span>, <span class="attr">name</span>: <span class="string">'客服部1'</span>, <span class="attr">orderNumber</span>: <span class="number">0.0</span>, <span class="attr">hasChild</span>: <span class="literal">false</span>, <span class="attr">enabled</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">'10'</span>, <span class="attr">parentId</span>: <span class="string">'2'</span>, <span class="attr">name</span>: <span class="string">'行政部1'</span>, <span class="attr">orderNumber</span>: <span class="number">0.0</span>, <span class="attr">hasChild</span>: <span class="literal">false</span>, <span class="attr">enabled</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">'14'</span>, <span class="attr">parentId</span>: <span class="string">'0'</span>, <span class="attr">name</span>: <span class="string">'外部的部门'</span>, <span class="attr">orderNumber</span>: <span class="number">0.0</span>, <span class="attr">hasChild</span>: <span class="literal">false</span>, <span class="attr">enabled</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></p><p>处理数据：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出根节点</span></span><br><span class="line"><span class="keyword">const</span> rootTreeData = treeData.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> item.parentId === <span class="string">'0'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出根节点后循环添加children</span></span><br><span class="line">rootTreeData.forEach(<span class="function">(<span class="params">root: any</span>) =&gt;</span> &#123;</span><br><span class="line">pushChildren(root.id, root)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理子节点，判断是否有children，有的话就递归添加children</span></span><br><span class="line"><span class="keyword">const</span> pushChildren = <span class="function">(<span class="params">id: string, root: &#123; children: any, hasChild: boolean &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">treeData.forEach(<span class="function">(<span class="params">item: any</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root.hasChild &amp;&amp; item.parentId === id) &#123;</span><br><span class="line"><span class="keyword">if</span> (!root.children) &#123;</span><br><span class="line">root.children = [];</span><br><span class="line">&#125;</span><br><span class="line">root.children.push(item)</span><br><span class="line">pushChildren(item.id, item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终的数据结构：<img src="/img/content/tree-data.png" alt="数据结构"><img src="/img/content/tree.png" alt="最终效果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基本数据：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;
      
    
    </summary>
    
      <category term="前端笔记" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="tips" scheme="github.com/MaTonna/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>使用Babel开发Typescript</title>
    <link href="github.com/MaTonna/2019/04/23/%E4%BD%BF%E7%94%A8Babel%E5%BC%80%E5%8F%91Typescript/"/>
    <id>github.com/MaTonna/2019/04/23/使用Babel开发Typescript/</id>
    <published>2019-04-23T03:12:07.986Z</published>
    <updated>2019-04-23T03:22:24.729Z</updated>
    
    <content type="html"><![CDATA[<h3>安装</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev typescript</span><br><span class="line">npm install --save-dev @babel/core</span><br><span class="line">npm install --save-dev @babel/cli</span><br><span class="line">npm install --save-dev @babel/plugin-proposal-class-properties</span><br><span class="line">npm install --save-dev @babel/plugin-proposal-object-rest-spread</span><br><span class="line">npm install --save-dev @babel/preset-env</span><br><span class="line">npm install --save-dev @babel/preset-typescript</span><br></pre></td></tr></table></figure></p><h3>配置</h3><h4>配置 tsconfig.json 文件</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    // Target latest version of ECMAScript.</span><br><span class="line">    &quot;target&quot;: &quot;esnext&quot;,</span><br><span class="line">    // Search under node_modules for non-relative imports.</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class="line">    // Process &amp; infer types from .js files.</span><br><span class="line">    &quot;allowJs&quot;: true,</span><br><span class="line">    // Don&apos;t emit; allow Babel to transform files.</span><br><span class="line">    &quot;noEmit&quot;: true,</span><br><span class="line">    // Enable strictest settings like strictNullChecks &amp; noImplicitAny.</span><br><span class="line">    &quot;strict&quot;: true,</span><br><span class="line">    // Disallow features that require cross-file information for emit.</span><br><span class="line">    &quot;isolatedModules&quot;: true,</span><br><span class="line">    // Import non-ES modules as default imports.</span><br><span class="line">    &quot;esModuleInterop&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;include&quot;: [</span><br><span class="line">    &quot;src&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>配置 babel</h4><p>在根目录下创建 .babelrc 文件，内容如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        &quot;@babel/preset-env&quot;,</span><br><span class="line">        &quot;@babel/preset-typescript&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;@babel/proposal-class-properties&quot;,</span><br><span class="line">        &quot;@babel/proposal-object-rest-spread&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>创建 src/index.ts 文件</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export class C &#123;</span><br><span class="line">    private x = 10</span><br><span class="line">    getX = () =&gt; this.x;</span><br><span class="line">    setX = (newVal: number) =&gt; &#123; this.x = newVal; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export let x = new C();</span><br><span class="line">export let y = &#123; ...&#123; some: &quot;value&quot; &#125; &#125;</span><br></pre></td></tr></table></figure></p><h4>配置 build 任务</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build:js&quot;: &quot;babel src --out-dir lib --extensions \&quot;.ts,.tsx\&quot; --source-maps inline&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>使用 TypeScript 开发 Ant Design</h3><h4>安装</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react react-dom @types/react @types/react-dom</span><br><span class="line">npm install --save-dev @babel/preset-react</span><br><span class="line">npm install --save antd</span><br></pre></td></tr></table></figure></p><p>安装 babel-plugin-import，可以提供按需加载功能</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-plugin-import</span><br></pre></td></tr></table></figure></p><p>.babelrc 文件要做相应的配置：</p><ul><li>在 presets 中增加 &quot;@babel/preset-react&quot;</li><li>plugins 中增加 [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;lib&quot;}, &quot;ant&quot;]</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        &quot;@babel/preset-env&quot;,</span><br><span class="line">        &quot;@babel/preset-react&quot;,</span><br><span class="line">        &quot;@babel/preset-typescript&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;@babel/proposal-class-properties&quot;,</span><br><span class="line">        &quot;@babel/proposal-object-rest-spread&quot;,</span><br><span class="line">        [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot;&#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>开发 React ，tsconfig.json 要做相应的配置，将 jsx 编译选项设为 react：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">     ...</span><br><span class="line">      &quot;jsx&quot;: &quot;react&quot; /* Specify JSX code generation: &apos;preserve&apos;, &apos;react-native&apos;, or &apos;react&apos;. */</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3>使用 webpack</h3><h4>安装</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack webpack-cli babel-loader</span><br><span class="line">npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure></p><h4>创建 webpack.config.js</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    // Change to your &quot;entry-point&quot;.</span><br><span class="line">    entry: &apos;./src/index&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: &apos;app.bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &apos;style-loader&apos;,</span><br><span class="line">                    &apos;css-loader&apos;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                // Include ts, tsx, js, and jsx files.</span><br><span class="line">                test: /\.(ts|js)x?$/,</span><br><span class="line">                exclude: /node_modules/,</span><br><span class="line">                loader: &apos;babel-loader&apos;,</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [&apos;.ts&apos;, &apos;.tsx&apos;, &apos;.js&apos;, &apos;.json&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4>创建 src/index.tsx</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import App from &quot;./App&quot;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App /&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></p><h4>创建 src/App.tsx</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; Button &#125; from &apos;antd&apos;;</span><br><span class="line"></span><br><span class="line">interface AppState &#123;</span><br><span class="line">    clickCount: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App extends React.Component&lt;any, AppState&gt; &#123;</span><br><span class="line"></span><br><span class="line">    constructor(props: any)&#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">        this.state = &#123;</span><br><span class="line">        clickCount: 0</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onButtonClick = () =&gt; &#123;</span><br><span class="line">        let count = this.state.clickCount + 1;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">        clickCount: count</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">                &lt;Button type=&quot;primary&quot; onClick=&#123;this.onButtonClick&#125;&gt;第&#123;this.state.clickCount&#125;次点击&lt;/Button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></p><h4>创建 dist/index.html 文件</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Ant Design&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>运行 webpack 命令打开 dist/index.html 文件，查看效果</p><p>参考资料：https://github.com/Microsoft/TypeScript-Babel-Starterhttps://zhuanlan.zhihu.com/p/59023070</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;
      
    
    </summary>
    
      <category term="前端笔记" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ts" scheme="github.com/MaTonna/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>H5的rem适配方案</title>
    <link href="github.com/MaTonna/2019/03/20/H5%E7%9A%84rem%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/"/>
    <id>github.com/MaTonna/2019/03/20/H5的rem适配方案/</id>
    <published>2019-03-20T02:36:01.214Z</published>
    <updated>2019-04-25T12:16:31.735Z</updated>
    
    <content type="html"><![CDATA[<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">doc, win</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> docEl = doc.documentElement,</span><br><span class="line">    resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,</span><br><span class="line">    <span class="comment">//750 为设计稿宽度  适配rem</span></span><br><span class="line">    recalc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> clientWidth = docEl.clientWidth;</span><br><span class="line">      <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span><br><span class="line">      clientWidth = clientWidth &lt;= <span class="number">1080</span> ? clientWidth : <span class="number">1080</span>;</span><br><span class="line">      docEl.style.fontSize = (clientWidth / <span class="number">750</span>) * <span class="number">100</span> + <span class="string">'px'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span><br><span class="line">  win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);</span><br><span class="line">  doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);</span><br><span class="line">&#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></p><p>       1rem = body 的 px 倍数，按照在 css 中就以设计稿/100 的 rem 来写。       按照爱疯 6 的 375 宽度来计算，根节点的 font-size 设置为 50px。</p><p>       另外，在公共的 css 中设置 body，确保在 PC 上查看页面也不会变形：</p><p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">min-width</span>: 320<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">max-width</span>: 640<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;sp
      
    
    </summary>
    
      <category term="tips" scheme="github.com/MaTonna/categories/tips/"/>
    
    
  </entry>
  
  <entry>
    <title>封装调用接口的函数，返回接口的返回值</title>
    <link href="github.com/MaTonna/2019/03/01/%E5%B0%81%E8%A3%85%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    <id>github.com/MaTonna/2019/03/01/封装调用接口的函数，返回接口的返回值/</id>
    <published>2019-03-01T07:11:19.430Z</published>
    <updated>2019-04-25T12:17:18.791Z</updated>
    
    <content type="html"><![CDATA[<ul><li>封装公共函数的 js：publicFunc.js</li></ul><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.get(url,param)</span><br><span class="line">      .then(<span class="function">(<span class="params">req</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = req;  <span class="comment">//接口返回值做处理</span></span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;getData&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>调用</li></ul><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">showMyData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">   <span class="keyword">let</span> data = <span class="keyword">await</span> getData();</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">     data</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;封装公共函数的 js：publicFunc.js&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="tips" scheme="github.com/MaTonna/categories/tips/"/>
    
    
  </entry>
  
  <entry>
    <title>解决IOS上new Image()的onload事件失效</title>
    <link href="github.com/MaTonna/2019/02/22/%E8%A7%A3%E5%86%B3IOS%E4%B8%8Anew%20Image()%E7%9A%84onload%E4%BA%8B%E4%BB%B6%E5%A4%B1%E6%95%88/"/>
    <id>github.com/MaTonna/2019/02/22/解决IOS上new Image()的onload事件失效/</id>
    <published>2019-02-22T08:26:46.100Z</published>
    <updated>2019-04-25T12:17:49.225Z</updated>
    
    <content type="html"><![CDATA[<h3>业务场景：</h3><p>H5 的客服中，根据用户输入付款金额以及选择付款方式，生成一张带有付款二维码、付款金额、若干提示语的图片。</p><h3>封装绘制方法的基本思路：</h3><ol><li>调用接口获得二维码图片地址</li><li>new Image()并 onload 后在 canvas 上绘制图片生成信息</li><li>完成绘制后执行回调，返回 canvas</li><li>回调中调用 canvas.toDataURL('image/png')将 canvas 转成 base64</li></ol><h3>遇到的问题：</h3><p>在 IOS 中无法绘制图片，经过排查发现是因为 onload 事件失效，所以使用 fetch()获取图片，在 then()中做后续操作。</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用绘制二维码</span></span><br><span class="line"><span class="keyword">this</span>.drawPayQRCode(&#123;</span><br><span class="line">  qrImgUrl: <span class="string">'二维码地址'</span>,</span><br><span class="line">  logoImgUrl: <span class="string">'支付通道的 logo'</span>,</span><br><span class="line">  sum: <span class="string">'金额'</span>,</span><br><span class="line">  userLoginName: <span class="string">'用户名'</span>,</span><br><span class="line">  branchName: <span class="string">'彩店名'</span>,</span><br><span class="line">  payproductName: <span class="string">'支付通道名'</span>,</span><br><span class="line">  tipList: [<span class="string">'文案 1'</span>,<span class="string">'文案 2'</span>,<span class="string">'文案 3'</span>],</span><br><span class="line">  callback: <span class="function"><span class="keyword">function</span>(<span class="params">canvas</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> imgUrl = canvas.toDataURL(<span class="string">'image/png'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义绘制二维码的方法</span></span><br><span class="line">drawPayQRCode(options) &#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">  <span class="keyword">const</span> canvasWidth = <span class="number">280</span>;</span><br><span class="line">  <span class="keyword">const</span> canvasHeight = <span class="number">270</span>;</span><br><span class="line">  canvas.width = canvasWidth;</span><br><span class="line">  canvas.height = canvasHeight;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义背景色</span></span><br><span class="line">  context.fillStyle = <span class="string">'#fff'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvasWidth, canvasHeight);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义二维码和支付通道 logo 的位置</span></span><br><span class="line">  <span class="keyword">const</span> qrL = (<span class="number">280</span> - <span class="number">150</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">const</span> qrR = <span class="number">26</span>;</span><br><span class="line">  <span class="keyword">const</span> qrWH = <span class="number">150</span>;</span><br><span class="line">  <span class="keyword">const</span> logoL = (<span class="number">280</span> - <span class="number">24</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">const</span> logoR = <span class="number">89</span>;</span><br><span class="line">  <span class="keyword">const</span> logoWH = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> qrImg = <span class="keyword">new</span> Image();</span><br><span class="line">  <span class="comment">// 判断机型为 ios</span></span><br><span class="line">  <span class="keyword">if</span> (CONFIG.browser.ios) &#123;</span><br><span class="line">     <span class="comment">// 加载二维码图片</span></span><br><span class="line">     <span class="keyword">this</span>.fetchImage(options.qrImgUrl, <span class="function"><span class="keyword">function</span>(<span class="params">myBlob</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">const</span> objectURL = URL.createObjectURL(myBlob); <span class="comment">// 将 Blob 生成 URL</span></span><br><span class="line">     qrImg.src = objectURL;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 延迟检查图片是否加载完成，可以改为轮询形式，complete 成功后关掉定时器</span></span><br><span class="line">     setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (qrImg.complete) &#123;</span><br><span class="line">        <span class="comment">// 绘制二维码图片</span></span><br><span class="line">        context.drawImage(qrImg, qrL, qrR, qrWH, qrWH);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> logoImg = <span class="keyword">new</span> Image();</span><br><span class="line">        <span class="comment">// 加载支付通道 logo，原理同上</span></span><br><span class="line">        <span class="keyword">this</span>.fetchImage(options.logoImgUrl, <span class="function"><span class="keyword">function</span>(<span class="params">myBlob</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">        logoImg.src = objectURL;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (logoImg.complete) &#123;</span><br><span class="line">           context.drawImage(logoImg, logoL, logoR, logoWH, logoWH);</span><br><span class="line">           <span class="comment">// 完成绘制后，执行回调</span></span><br><span class="line">           options.callback(canvas);</span><br><span class="line">         &#125;</span><br><span class="line">         &#125;, <span class="number">60</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">      &#125;, <span class="number">60</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//图片跨域访问</span></span><br><span class="line">     qrImg.setAttribute(<span class="string">'crossOrigin'</span>, <span class="string">'Anonymous'</span>);</span><br><span class="line"></span><br><span class="line">     qrImg.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     context.drawImage(qrImg, qrL, qrR, qrWH, qrWH);</span><br><span class="line">     <span class="comment">//下载支付通道 logo</span></span><br><span class="line">     <span class="keyword">const</span> logoImg = <span class="keyword">new</span> Image();</span><br><span class="line">     logoImg.setAttribute(<span class="string">'crossOrigin'</span>, <span class="string">'Anonymous'</span>);</span><br><span class="line"></span><br><span class="line">     logoImg.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        context.drawImage(logoImg, logoL, logoR, logoWH, logoWH);</span><br><span class="line">        <span class="comment">// 完成绘制后，回调</span></span><br><span class="line">        options.callback(canvas);</span><br><span class="line">      &#125;;</span><br><span class="line">     logoImg.src = options.logoImgUrl;</span><br><span class="line">   &#125;;</span><br><span class="line">     qrImg.src = options.qrImgUrl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  context.font = <span class="string">'12px Helvetica Neue,Tahoma,Arial,PingFangSC-Regular,Hiragino Sans GB,Microsoft Yahei,sans-serif'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 金额样式</span></span><br><span class="line">  context.fillStyle = <span class="string">'#f00'</span>;</span><br><span class="line">  context.textAlign = <span class="string">'center'</span>;</span><br><span class="line">  context.fillText(<span class="string">`￥<span class="subst">$&#123;options.sum&#125;</span>`</span>, <span class="number">140</span>, <span class="number">26</span> + <span class="number">150</span> + <span class="number">10</span>);</span><br><span class="line">  context.fillText(<span class="string">`仅限<span class="subst">$&#123;options.userLoginName&#125;</span> <span class="subst">$&#123;options.branchName&#125;</span>使用`</span>, <span class="number">140</span>, <span class="number">26</span> + <span class="number">150</span> + <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提示语样式</span></span><br><span class="line">  context.fillStyle = <span class="string">'#000'</span>;</span><br><span class="line">  context.textAlign = <span class="string">'left'</span>;</span><br><span class="line">  <span class="keyword">const</span> tipList = options.tipList;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果是微信付款就添加提交数据</span></span><br><span class="line">  <span class="keyword">if</span> (options.payproductName === <span class="string">'WECHAT'</span>) &#123;</span><br><span class="line">     tipList[<span class="number">0</span>] = <span class="string">'请打开微信 APP 扫一扫'</span>;</span><br><span class="line">     tipList.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'请勿在扫码页面从相册选取二维码进行识别'</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> len = tipList.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">     context.fillText(i + <span class="number">1</span> + <span class="string">'.'</span> + tipList[i] + (i === len - <span class="number">1</span> ? <span class="string">'。'</span> : <span class="string">'；'</span>), <span class="number">16</span>, <span class="number">220</span> + <span class="number">16</span> \* i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">fetchImage(imgUrl, cb) &#123;</span><br><span class="line">  fetch(imgUrl)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res.ok) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.blob();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">myBlob</span>) </span>&#123;</span><br><span class="line">    cb(myBlob);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>       由于fetch有些兼容性的问题，所以会考虑到用xhr来实验一下，用xhr来获取图片的Blob：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;img id=<span class="string">"myImg"</span> src=<span class="string">""</span> /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">loadImage</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      callback = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(url);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.responseType = <span class="string">'blob'</span>;</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">      <span class="keyword">const</span> resToUrl = <span class="built_in">window</span>.URL.createObjectURL(xhr.response);</span><br><span class="line">      <span class="built_in">console</span>.log(resToUrl)</span><br><span class="line">      callback(resToUrl);</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用方法</span></span><br><span class="line">  <span class="keyword">var</span> imgUrl = <span class="string">'http://qimg.hxnews.com/2019/0203/1549199908936.jpg'</span>;</span><br><span class="line">  loadImage(imgUrl, <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'myImg'</span>).setAttribute(<span class="string">'src'</span>, url);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;业务场景：&lt;/h3&gt;
&lt;p&gt;H5 的客服中，根据用户输入付款金额以及选择付款方式，生成一张带有付款二维码、付款金额、若干提示语的图片。&lt;/p&gt;
&lt;h3&gt;封装绘制方法的基本思路：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;调用接口获得二维码图片地址&lt;/li&gt;
&lt;li&gt;new Image(
      
    
    </summary>
    
      <category term="tips" scheme="github.com/MaTonna/categories/tips/"/>
    
    
      <category term="日常tips" scheme="github.com/MaTonna/tags/%E6%97%A5%E5%B8%B8tips/"/>
    
  </entry>
  
  <entry>
    <title>小程序-组件篇</title>
    <link href="github.com/MaTonna/2019/02/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%BB%84%E4%BB%B6/"/>
    <id>github.com/MaTonna/2019/02/20/小程序-组件/</id>
    <published>2019-02-20T03:19:51.398Z</published>
    <updated>2019-02-20T03:29:48.157Z</updated>
    
    <content type="html"><![CDATA[<h3>使用方法</h3><p>       与页面类似，一个自定义组件也由 json、wxml、wxss、js 四个文件组成。编写自定义组件需要在 json 文件中声明：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;component&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>       在页面中使用自定义组件之前，要在页面的 json 文件中进行引用声明：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;usingComponents&quot;: &#123;</span><br><span class="line">        // 自定义标签名只能包含小写字母，中划线和下划线</span><br><span class="line">        &quot;component-tag-name&quot;: &quot;page/to/custom/component&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>       然后就可以使用自定义组件：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;component-tag-name inner-text=&quot;Some text&quot;&gt;&lt;/component-tag-name&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><h3>组件模板和样式</h3><p>       可以向组件传递&lt;slot&gt;节点，用于承载需要组件引用的子节点。需要使用多个 slot 时需要在组件的 js 中声明，用 name 区分：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//组件 js</span><br><span class="line">Component(&#123;</span><br><span class="line">   options: &#123;</span><br><span class="line">       multipleSlots: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//组件 wxml</span><br><span class="line">&lt;view class=&quot;wrapper&quot;&gt;</span><br><span class="line"> &lt;slot name=&quot;before&quot;&gt;&lt;/slot&gt;</span><br><span class="line"> &lt;view&gt;这里是组件的内部细节&lt;/view&gt;</span><br><span class="line"> &lt;slot name=&quot;after&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">//页面 wxml</span><br><span class="line">&lt;view&gt;</span><br><span class="line"> // 可以使用数据绑定向子组件的属性传递动态数据</span><br><span class="line"> &lt;component-tag-name prop-a=&quot;&#123;&#123;dataFieldA&#125;&#125;&quot; prop-b=&quot;&#123;&#123;dataFieldB&#125;&#125;&quot;&gt;</span><br><span class="line">   &lt;view slot=&quot;before&quot;&gt;这里是插入到组件 slot name=&quot;before&quot;中的内容&lt;/view&gt;</span><br><span class="line">   &lt;view slot=&quot;after&quot;&gt;这里是插入到组件 slot name=&quot;after&quot;中的内容&lt;/view&gt;</span><br><span class="line"> &lt;/component-tag-name&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><p>       组件对应的 wxss 文件的样式只对组件 wxml 内的节点生效，在组件内不能使用 id、属性、标签、后代选择器，子元素选择器&gt;只能用于 view 组件和其子节点。可以使用:host 指定所在节点的默认样式。       在自定义组件激活 addGlobalClass 选项可以让自定义组件能被 app.wxss 或页面的 wxss 中的所有样式影响。       在 Component 中可以用 externalClasses 定义若干个外部样式类，样式类是写在页面中的。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 页面 wxml</span><br><span class="line">&lt;custom-component my-class=&quot;red-text&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 组件 wxml    </span><br><span class="line">&lt;custom-component class=&quot;my-class&quot;&gt;</span><br><span class="line">  这段文本的颜色由组件外的 class 决定</span><br><span class="line">&lt;/custom-component&gt;</span><br><span class="line"></span><br><span class="line">// 组件 js</span><br><span class="line">Component(&#123;</span><br><span class="line"> externalClasses: [&apos;my-class&apos;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3>Component 构造器</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line"> // 用于组件间的代码共享，可以使用 Behavior()构造器定义，每个 behavior 包含一组属性、数据、声明周期和方法，被组件引用时，这些东西会被合并到组件中去</span><br><span class="line"> behaviors: [],</span><br><span class="line"></span><br><span class="line"> properties: &#123;</span><br><span class="line">   // 如果用 Component 构造页面，在 properties 中可以接收到页面参数</span><br><span class="line">   myProperty: &#123; // 属性名</span><br><span class="line">     type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）</span><br><span class="line"></span><br><span class="line">     value: &apos;&apos;, // 属性初始值（可选），如果未指定则会根据类型选择一个</span><br><span class="line"></span><br><span class="line">     observer(newVal, oldVal, changedPath) &#123;</span><br><span class="line">       // 属性被改变时执行的函数（可选），也可以写成在 methods 段中定义的方法名字符串, 如：&apos;\_propertyChange&apos;</span><br><span class="line">       // 通常 newVal 就是新设置的数据， oldVal 是旧数据</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">   myProperty2: String // 简化的定义方式</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> data: &#123;&#125;, // 私有数据，可用于模板渲染</span><br><span class="line"></span><br><span class="line"> lifetimes: &#123;</span><br><span class="line">   // 生命周期函数，可以为函数，或一个在 methods 段中定义的方法名</span><br><span class="line">   attached() &#123; &#125;, // 在组件实例进入页面节点树时</span><br><span class="line"></span><br><span class="line">   moved() &#123; &#125;, // 在组件实例被移动到节点树另一个位置时执行</span><br><span class="line"></span><br><span class="line">   detached() &#123; &#125;, // 在组件实例从页面节点树移除时执行</span><br><span class="line"></span><br><span class="line">   // 还有 created、ready、error 生命周期</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> pageLifetimes: &#123;</span><br><span class="line">   // 组件所在页面的生命周期函数</span><br><span class="line"></span><br><span class="line">   show() &#123; &#125;, // 页面被展示时执行</span><br><span class="line"></span><br><span class="line">   hide() &#123; &#125;, // 页面被隐藏时执行</span><br><span class="line"></span><br><span class="line">   resize() &#123; &#125;, //页面尺寸变化时执行</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> methods: &#123;</span><br><span class="line">   onMyButtonTap() &#123;</span><br><span class="line">     this.setData(&#123;</span><br><span class="line">       // 更新属性和数据的方法与更新页面数据的方法类似</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   // 内部方法建议以下划线开头</span><br><span class="line">   _myPrivateMethod() &#123;</span><br><span class="line">     // 这里将 data.A[0].B 设为 &apos;myPrivateData&apos;</span><br><span class="line">     this.setData(&#123;</span><br><span class="line">       &apos;A[0].B&apos;: &apos;myPrivateData&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   _propertyChange(newVal, oldVal) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>       组件中包含一些通用属性和方法，可以通过 this 访问：<img src="/img/content/component-this.png" alt="组件的通用属性和方法"></p><h3>组件间通信、事件与关系</h3><h4>组件间通信</h4><p>       父 -&gt; 子：wxml 数据绑定通过设置属性传递数据，或通过 this.selectComponent 方法获取子组件实例对象       子 -&gt; 父：通过事件传递数据</p><h4>监听/触发事件</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 监听事件</span><br><span class="line">// 父组件 wxml</span><br><span class="line">&lt;component-tag-name bind:myevent=&quot;onMyEvent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 父组件 js</span><br><span class="line">Page(&#123;</span><br><span class="line"> onMyEvent(e) &#123;</span><br><span class="line">   e.detail // 自定义组件触发事件时提供的 detail 对象</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 触发事件</span><br><span class="line">// 子组件 wxml</span><br><span class="line">&lt;button bind:tap=&quot;onTap&quot;&gt;点击这个按钮将触发“myevent”事件&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">// 子组件 js</span><br><span class="line">Component(&#123;</span><br><span class="line"> properties: &#123;&#125;,</span><br><span class="line"></span><br><span class="line"> methods: &#123;</span><br><span class="line">   onTap() &#123;</span><br><span class="line">     const myEventDetail = &#123;&#125; // detail 对象，提供给事件监听函数</span><br><span class="line"></span><br><span class="line">     // 触发事件的选项</span><br><span class="line">     const myEventOption = &#123;</span><br><span class="line">         bubbles: Boolean,    // 表示事件是否冒泡，默认为 false</span><br><span class="line">         composed: Boolean,    // 表示事件是否可以穿越组件边界，默认为 false</span><br><span class="line">         capturePhase: Boolean,    //表示事件是否有捕获阶段，默认为 false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     this.triggerEvent(&apos;myevent&apos;, myEventDetail, myEventOption)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4>组件间关系</h4><p>       如果两个自定义组件有嵌套关系，相互间的通信比较复杂，可以加入 relations 定义段。需要在两个组件定义中都加入 relations 定义，否则不会生效。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 组件 wxml</span><br><span class="line">&lt;custom-ul&gt;</span><br><span class="line"> &lt;custom-li&gt;item 1&lt;/custom-li&gt;</span><br><span class="line"> &lt;custom-li&gt;item 2&lt;/custom-li&gt;</span><br><span class="line">&lt;/custom-ul&gt;</span><br><span class="line"></span><br><span class="line">// 外层组件 js</span><br><span class="line">Component(&#123;</span><br><span class="line"> relations: &#123;</span><br><span class="line">   &apos;./custom-li&apos;: &#123;</span><br><span class="line">     type: &apos;child&apos;, // 关联的目标节点应为子节点</span><br><span class="line"></span><br><span class="line">     linked(target) &#123;</span><br><span class="line">       // 每次有 custom-li 被插入时执行，target 是该节点实例对象，触发在该节点 attached 生命周期之后</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">     linkChanged(target) &#123;</span><br><span class="line">       // 每次有 custom-li 被移动后执行，target 是该节点实例对象，触发在该节点 moved 生命周期之后</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">     unlinked(target) &#123;</span><br><span class="line">       // 每次有 custom-li 被移除时执行，target 是该节点实例对象，触发在该节点 detached 生命周期之后</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> methods: &#123;</span><br><span class="line">   _getAllLi() &#123;</span><br><span class="line">     // 使用 getRelationNodes 可以获得 nodes 数组，包含所有已关联的 custom-li，且是有序的</span><br><span class="line">     const nodes = this.getRelationNodes(&apos;path/to/custom-li&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> ready() &#123;</span><br><span class="line">   this._getAllLi()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>       内层组件写法类似，type 为 parent，linked / linkChanged / unlinked 代表被插入/移动/移除时执行。       如果外层组件想要关联两个内层组件，并且如果两个组件都有一个 behavior：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 组件 wxml</span><br><span class="line">&lt;custom-form&gt;</span><br><span class="line"> &lt;view&gt;</span><br><span class="line">   input</span><br><span class="line">   &lt;custom-input&gt;&lt;/custom-input&gt;</span><br><span class="line"> &lt;/view&gt;</span><br><span class="line"> &lt;custom-submit&gt;submit&lt;/custom-submit&gt;</span><br><span class="line">&lt;/custom-form&gt;</span><br><span class="line"></span><br><span class="line">// 外层组件 js</span><br><span class="line">const customFormControls = require(&apos;./custom-form-controls&apos;)</span><br><span class="line">Component(&#123;</span><br><span class="line"> relations: &#123;</span><br><span class="line">   customFormControls: &#123;</span><br><span class="line">     type: &apos;descendant&apos;, // 关联的目标节点应为子孙节点</span><br><span class="line">     target: customFormControls</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 内层组件 js</span><br><span class="line">const customFormControls = require(&apos;./custom-form-controls&apos;)</span><br><span class="line">Component(&#123;</span><br><span class="line"> behaviors: [customFormControls],</span><br><span class="line"></span><br><span class="line"> relations: &#123;</span><br><span class="line">   &apos;./custom-form&apos;: &#123;</span><br><span class="line">     type: &apos;ancestor&apos;, // 关联的目标节点应为祖先节点</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3>抽象节点</h3><p>       当自定义组件模板中的节点由调用者决定时，就可以把节点声明为抽象节点。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 一个选框组组件，可以放置单选框或者复选框</span><br><span class="line">// 组件 wxml</span><br><span class="line">&lt;view wx:for=&quot;&#123;&#123;labels&#125;&#125;&quot;&gt;</span><br><span class="line"> &lt;label&gt;</span><br><span class="line">   &lt;selectable disabled=&quot;&#123;&#123;false&#125;&#125;&quot;&gt;&lt;/selectable&gt;</span><br><span class="line">  &#123;&#123;item&#125;&#125;</span><br><span class="line"> &lt;/label&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">// 组件 json</span><br><span class="line">&#123;</span><br><span class="line"> &quot;componentGenerics&quot;: &#123;</span><br><span class="line">   &quot;selectable&quot;: true</span><br><span class="line">   // 可以指定一个默认组件</span><br><span class="line">   //&quot;selectable&quot;: &#123;</span><br><span class="line">   // &quot;default&quot;: &quot;path/to/default/component&quot;</span><br><span class="line">   //&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用组件的 wxml</span><br><span class="line">&lt;selectable-group generic:selectable=&quot;custom-radio&quot; /&gt;</span><br><span class="line">&lt;selectable-group generic:selectable=&quot;custom-checkbox&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 调用组件的 json，有可能调用的组件都需要包含在 json 的 usingComponent 中</span><br><span class="line">&#123;</span><br><span class="line"> &quot;usingComponents&quot;: &#123;</span><br><span class="line">   &quot;custom-radio&quot;: &quot;path/to/custom/radio&quot;,</span><br><span class="line">   &quot;custom-checkbox&quot;: &quot;path/to/custom/checkbox&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;使用方法&lt;/h3&gt;
&lt;p&gt;       与页面类似，一个自定义组件也由 json、wxml、wxss、js 四个文件组成。编写自定义组件需要在 json 文件中声明：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="前端笔记" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="小程序" scheme="github.com/MaTonna/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序-框架基础篇</title>
    <link href="github.com/MaTonna/2019/02/18/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%9F%BA%E7%A1%80/"/>
    <id>github.com/MaTonna/2019/02/18/小程序-基础/</id>
    <published>2019-02-18T09:36:25.729Z</published>
    <updated>2019-02-20T03:20:06.867Z</updated>
    
    <content type="html"><![CDATA[<h3>vscode 插件：</h3><p>       minapp-标签属性智能补全</p><h3>框架：</h3><h4>1.小程序的启动</h4><p>       微信在打开小程序之前，把整个代码包下载到本地       读取 app.json 的 pages 字段知道所有的页面路径，然后通过 pages 字段的第一个值的路径装载并渲染首页       启动后，在 app.js 定义的 App 实例的 onLaunch 回调被执行</p><h4>2.注册程序：App()</h4><p>       app.js：是小程序入口，其中调用 App()函数来注册一个小程序，参数为小程序的声明周期回调等等</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  onLaunch(options) &#123;</span><br><span class="line">    // 初始化完成时调用（全局只触发一次）</span><br><span class="line">    // 参数里可以拿到当前路径、场景代号等，可以通过wx.getLaunchOptionsSync获取</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onShow(options) &#123;</span><br><span class="line">    // 在启动、从后台进入前台时调用（后台是指用户点击右上角的关闭或者按了设备的home键离开微信，再次打开时进入前台）</span><br><span class="line">    // 小程序运行机制：https://developers.weixin.qq.com/miniprogram/dev/framework/operating-mechanism.html</span><br><span class="line">    // 用wx.onAppShow可以绑定监听</span><br><span class="line">    // 参数同onLaunch</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onHide() &#123;</span><br><span class="line">    // 从前台进入后台时触发</span><br><span class="line">    // 用wx.onAppHide可以绑定监听</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onError(msg) &#123;</span><br><span class="line">    // 脚本错误、api调用失败时触发</span><br><span class="line">    // 用wx.onError可以绑定监听</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onPageNotFound() &#123;</span><br><span class="line">    // 要打开的页面不存在时触发</span><br><span class="line">    // 参数带有页面信息</span><br><span class="line">    // 用wx.onPageNotFound可以绑定监听</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 除此之外可以添加任意方法或数据</span><br><span class="line">  // 可以用this可以访问</span><br><span class="line">  globalData: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>       全局的 getApp()函数可以用来获取到小程序 App 实例。</p><h4>3.注册页面：Page()</h4><p>       Page(Object)用来注册一个页面，参数可以指定页面的初试数据，生命周期回调，事件处理函数等。       高级用法是用 Component 创建页面，就可以使用自定义组件的特性，比如用 behaviors 进行代码复用。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    // 页面初始数据，页面加载时data会以JSON字符串的形式由逻辑层传至渲染层</span><br><span class="line">    // data中的数据必须是字符串、数字、布尔值、对象、数组</span><br><span class="line">    // 渲染层可以通过WXML进行数据绑定</span><br><span class="line">    text: &apos;This is page data.&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onLoad(query) &#123;</span><br><span class="line">    // 监听页面加载</span><br><span class="line">    // 参数可以获取打开当前页面路径中的参数</span><br><span class="line">    // 例：当前url为../logs/logs?abc=1，参数query即为&#123;&quot;abc&quot;: 1&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onShow() &#123;</span><br><span class="line">    // 监听页面显示/切入前台事件</span><br><span class="line">    console.log(this.route) // this中还有当前页面的路径</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onReady() &#123;</span><br><span class="line">    // 监听页面初次渲染完成，一个页面只会调用一次，表示页面可以和视图层进行交互</span><br><span class="line">    // 如果要对界面内容进行设置，要在onReady之后的生命周期进行</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onHide() &#123;</span><br><span class="line">    // 监听页面隐藏/切入后台事件</span><br><span class="line">    // 如navigateTo或tab切换到其他页面</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onUnload() &#123;</span><br><span class="line">    // 监听页面卸载</span><br><span class="line">    // 如redireactTo或navigateBack到其他页面</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onPullDownRefresh() &#123;</span><br><span class="line">    // 监听用户下拉刷新动作</span><br><span class="line">    // 需要在app.json的window选项或页面配置中开启enablePullDownRefresh</span><br><span class="line">    // 可以通过wx.startPullDownRefresh触发</span><br><span class="line">    // 处理完数据刷新后，wx.stopPullDownRefresh可以停止下拉刷新</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onReachBottom() &#123;</span><br><span class="line">    // 监听上拉触底事件</span><br><span class="line">    // 在app.json的window选项或页面配置中设置触发距离onReachBottomDistance</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onShareAppMessage(Object) &#123;</span><br><span class="line">    // 用户点击右上角转发，或点击转发按钮&lt;button open-type=&quot;share&quot; /&gt;</span><br><span class="line">    // 参数 Object包含from: button/menu，target:button/undefined，webViewUrl:&lt;web-view&gt;的url</span><br><span class="line">    return &#123;</span><br><span class="line">        title: &apos;&apos;, // 默认为当前小程序名称</span><br><span class="line">        path: &apos;&apos;, // 转发路径，当前页面的完整路径</span><br><span class="line">        imageUrl: &apos;&apos; // 显示图片路径，支持png/jpg，默认使用默认截图，长宽比为5:4</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onPageScroll(Object) &#123;</span><br><span class="line">    // 页面滚动触发事件</span><br><span class="line">    // 参数中的scrollTop可以获取页面在垂直方向已滚动的距离px</span><br><span class="line">    // 不要定义空方法，减少不必要的事件派发对渲染层-逻辑层通信的影响</span><br><span class="line">    // 避免过于频繁的执行setState引起通信操作，传递大量数据会影响通信耗时</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onResize(res) &#123;</span><br><span class="line">    // 页面尺寸改变触发事件</span><br><span class="line">    // 在手机上/ipad启用屏幕旋转支持可以触发</span><br><span class="line">    // 读取页面的显示尺寸，可以用SelectorQuery.selectViewport()</span><br><span class="line">    res.size.windowWidth // 新的显示区域宽度</span><br><span class="line">    res.size.windowHeight // 新的显示区域高度</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onTabItemTap(item) &#123;</span><br><span class="line">    // 当前是tab页时，点击tab时触发</span><br><span class="line">    console.log(item.index) // 被点击tabItem的序号</span><br><span class="line">    console.log(item.pagePath) // 被点击tabItem的页面路径</span><br><span class="line">    console.log(item.text) // 被点击tabItem的按钮文字</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 其他函数和数据</span><br><span class="line">  // 定义组件事件处理函数，在渲染层的组件中加入事件绑定，就会进入到事件处理函数</span><br><span class="line">  // &lt;view bindtap=&quot;viewTap&quot;&gt;click me&lt;/view&gt;</span><br><span class="line">  viewTap() &#123;</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      text: &apos;Set some data for updating view.&apos;</span><br><span class="line">      // 支持修改数组中的某一项或对象的某个属性，并且可以不需要在this.data中预先定义，不要设为undefined</span><br><span class="line">    &#125;, function () &#123;</span><br><span class="line">      // this is setData callback</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  customData: &#123;</span><br><span class="line">    hi: &apos;MINA&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4>4.页面路由</h4><p>       所有页面的路由都由框架以栈的形式进行管理。getCurrentPages()用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。       App.onLaunch 的时候不要调用 getCurrentPages()，这时候 page 还没有生成。       路由方式和对应的声明周期：<img src="/img/content/wx-router.png" alt="路由方式和对应的声明周期">Tab 切换对应的生命周期，A、B 为 tabbar 页面，C 是从 A 页面打开的，D 是从 C 页面打开的<img src="/img/content/wx-router-tab.png" alt="Tab切换对应的生命周期"></p><h4>5.WXML 和 vue 的 template 用法区别</h4><ul><li><p>列表渲染         不需要写 item,index in array，默认当前项变量名为 item，当前下标变量名为 index，可以使用 wx:for-item、wx:for-index 重新制定当前元素和下标的变量名。          如果是动态渲染的列表，需要用 wx:key 来制定列表中项目的唯一标识符，值可以是唯一的字符串/数字，或保留关键字*this（代表在 for 循环中的 item 本身）。当数据改变触发渲染层重新渲染时，会矫正带有 key 的组件，确保他们被重新排序而不是重新创建，以确保使组件保持自身的状态，提高列表渲染时的效率。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt;&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><p>注：wx:for 的值为字符串时，会将字符串解析成字符串数组，花括号之间有空格，会被解析成字符串。</p></li><li><p>事件使用方式       冒泡事件：key 以 bind（不会阻止冒泡事件向上冒泡）、catch（阻止冒泡事件向上冒泡）开头，非原生组件中，bind 和 catch 可以紧跟一个冒号，含义不变，如 bind-tap       非冒泡事件：key 以 capture-bind、capture-catch（中断捕获阶段和取消冒泡阶段）</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;tapName&quot;&gt;点击&lt;/view&gt;</span><br></pre></td></tr></table></figure></p></li></ul><p>       支持使用 WXS 函数绑定时间，接收 event 和 ownerInstance 两个参数，ownerInstance 和 event.instance 一样是一个 ComponentDescriptor 对象，可以设置组件的样式和 class。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;wxs module=&quot;wxs&quot; src=&quot;./test.wxs&quot;&gt;&lt;/wxs&gt;</span><br><span class="line">&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;&#123;&#123;wxs.tapName&#125;&#125;&quot;&gt;点击&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">// test.wxs</span><br><span class="line">function tapName(event, ownerInstance) &#123;</span><br><span class="line"> console.log(&apos;tap wechat&apos;, JSON.stringify(event))</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> tapName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>文件引用方式</li></ul><p>       import：在文件中使用目标文件定义的 template，有作用域的概念，不会 import 目标文件 import 的 template。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- A.wxml --&gt;</span><br><span class="line">&lt;template name=&quot;A&quot;&gt;</span><br><span class="line">  &lt;text&gt;A template&lt;/text&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- B.wxml --&gt;</span><br><span class="line">&lt;import src=&quot;a.wxml&quot; /&gt;</span><br><span class="line">&lt;template is=&quot;A&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>       include：将目标文件除了template标签和wxs标签之外的整个代码引入，相当于拷贝到 include 位置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.wxml --&gt;</span><br><span class="line">&lt;include src=&quot;header.wxml&quot; /&gt;</span><br><span class="line">&lt;view&gt;body&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- header.wxml --&gt;</span><br><span class="line">&lt;view&gt;header&lt;/view&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;vscode 插件：&lt;/h3&gt;
&lt;p&gt;       minapp-标签属性智能补全&lt;/p&gt;
&lt;h3&gt;框架：&lt;/h3&gt;
&lt;h4&gt;1.小程序的启动&lt;/h4&gt;
&lt;p&gt;       微信在打开小程序之前，把整个代码包下载到本地
       读取 app.json 的 pages
      
    
    </summary>
    
      <category term="前端笔记" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="小程序" scheme="github.com/MaTonna/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存机制</title>
    <link href="github.com/MaTonna/2019/02/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>github.com/MaTonna/2019/02/12/浏览器缓存机制/</id>
    <published>2019-02-12T03:40:59.240Z</published>
    <updated>2019-04-25T12:17:49.331Z</updated>
    
    <content type="html"><![CDATA[<p>       缓存可以简单高效的优化性能，可以显著减少网络传输带来的损耗。浏览器缓存可以帮我们在数据请求中的网络请求和浏览器响应这两步优化性能，直接使用缓存而不发起请求，或者发起请求但是后端存储的数据和前端一致，就没有必要将数据返回回来，就减少了响应数据。</p><h3>1. 缓存位置</h3><h4>Service Worker</h4><p>       它是浏览器背后的独立线程，一般用来实现缓存功能。传输协议必须是 https，因为涉及到请求拦截，必须用 https 协议来保障安全。       实现缓存功能步骤：</p><ol><li>注册 Service Worker</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">'sw.js'</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'service worker 注册成功'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'servcie worker 注册失败'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>监听到 install 事件，缓存需要的文件</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听 `install` 事件，回调中缓存所需文件</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, e =&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'my-cache'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([<span class="string">'./index.html'</span>, <span class="string">'./index.js'</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ol start="3"><li>下次用户访问就通过拦截请求查询是否存在缓存，存在则直接读取文件，否则就去请求数据</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截所有请求事件</span></span><br><span class="line"><span class="comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, e =&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'fetch source'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>       在开发者工具中的 Application 可以看到 Service Worker 已经启动，Cache 中也可以看到我们缓存的文件。</p><h4>Memory Cache</h4><p>       Memory Cache 是内存中的缓存，读取速度比磁盘快，但是缓存持续时间短，随着进程的释放而释放，一旦关闭 tab 页，内存中的缓存就会被释放。       但是不能让数据都存在内存中，计算机内存比硬盘容量小，大文件一般不存储在内存中，内存如果使用率高，文件会优先存储进硬盘。</p><h4>Disk Cache</h4><p>       Disk Cache 是存储在硬盘中的缓存，虽然速度较慢，但是比 Memory Cache 胜在容量和存储时效性上。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。即使跨站点，相同地址的资源一旦被硬盘缓存下来就不会重新请求数据。</p><h4>Push Cache</h4><p>       Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时才会使用，缓存时间短暂，只在 session 中，一旦 session 结束就会被释放。</p><h3>2. 缓存策略</h3><p>       浏览器缓存策略分为强缓存和协商缓存两种，都是通过设置 HTTP Header 来实现的。</p><h4>强缓存</h4><p>       强缓存表示在缓存期间不需要请求，state code 为 200。</p><ol><li>设置 Expires</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Oct <span class="number">2018</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure></p><p>       表示会在特定的时间后过期，需要再次请求。但是 Expires 受限于本地时间，修改了本地时间可能会造成缓存失败。</p><ol start="2"><li>设置 Cache-control</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-control: max-age=<span class="number">30</span></span><br></pre></td></tr></table></figure></p><p>       表示资源会在 30s 后过期，需要再次请求，优先级高于 Expires，可以在请求头或者响应头中设置，可以组合使用多种指令。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。<img src="/img/content/cache-control.png" alt="常见指令作用"></p><h4>协商缓存</h4><p>       协商缓存表示如果缓存过期了，需要发起请求验证资源是否有更新。当浏览器发起请求验证资源时，如果资源没有改变则返回 304，并且更新浏览器缓存有效期。</p><ol><li>设置 Last-Modified       Last-Modified 表示本地文件最后修改地址，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话则讲新的资源文件发送回来，否则返回 304。       但是如果本地打开了缓存文件，会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源。Last-Modified 以秒计时，如果在不可感知的时间内修改完文件，服务端则认为资源命中，不会返回正确的资源。</li><li>设置 ETag       ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问 ETag 是否改变，有变动就发送新资源回来，并且优先级高于 Last-Modified。</li></ol><p>       <strong>如果没有设置任何缓存策略，浏览器会采用一个启发式的算法，通常取响应头中的 Date 减去 Last-Modified 值的 10%作为缓存时间。</strong>       <strong>缓存的优先级：Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified</strong><img src="/img/content/cache-flow.png" alt="浏览器缓存机制流程图"></p><h3>实际场景应用缓存策略</h3><h4>频繁变动的资源</h4><p>       频繁变动的资源首先使用 Cache-Control: no-cache 使浏览器每次都请求服务器，再配合 ETag 或者 Last-Modified 来验证资源是否有效，可以减少响应数据的大小。</p><h4>代码文件</h4><p>       可以用打包工具给文件名进行哈希处理，代码修改后才会生成新的文件名。然后就可以给代码文件设置一年的有效期 Cache-Control: max-age=3153600，这样就只有当 HTML 文件引入的文件名发生变化才会去下载最新的代码文件，否则就一直使用缓存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;       缓存可以简单高效的优化性能，可以显著减少网络传输带来的损耗。浏览器缓存可以帮我们在数据请求中的网络请求和浏览器响应这两步优化性能，直接使用缓存而不发起请求，或者发起请求但是后端存储的数据和前端一致，就没有必要将数据返回回来，就减少了响应数据。&lt;/p&gt;
&lt;h3&gt;
      
    
    </summary>
    
      <category term="前端面试之道" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="面试" scheme="github.com/MaTonna/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浏览器基础知识点及常考面试题</title>
    <link href="github.com/MaTonna/2019/01/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>github.com/MaTonna/2019/01/25/浏览器基础知识点及常考面试题/</id>
    <published>2019-01-25T07:12:21.048Z</published>
    <updated>2019-04-25T12:17:31.613Z</updated>
    
    <content type="html"><![CDATA[<h3>1. 事件机制</h3><p>       <strong>面试题：事件的触发过程是怎么样的？什么是事件代理？</strong></p><ul><li>事件触发事件触发的三个阶段：</li></ul><ol><li>从 window 往事件触发处传播，遇到注册的捕获事件会触发</li><li>传播到事件触发处时触发注册的时间</li><li>从事件触发处往 window 传播，遇到注册的冒泡事件会触发</li></ol><p>       **注：**如果给 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。       通常使用 addEventListener 注册事件，第三个参数是布尔值或者对象，布尔值默认为 false 表示捕获，对象可以使用{captrue:布尔值（true 冒泡，false 捕获）, once:布尔值（true 表示回调只会调用一次，调用后移除）, passive:布尔值（true 表示永远不会调用 preventDefault）}       stopPropagation 可以阻止事件的冒泡和捕获，stopImmediatePropagation 也可以阻止事件，还能阻止该事件目标执行别的注册事件。</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// node被点击后，以下的事件不会执行了</span></span><br><span class="line">node.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><ul><li>事件代理（事件委托）       只指定一个事件处理程序，就可以管理某一类型的所有事件。原理是利用事件的冒泡机制，从最深的节点开始逐渐向上传播事件，冒泡到指定的父节点代为执行事件。       例如， ul 上面的所有 li 都需要相同的 click 事件，没有用事件代理就会用 for 循环的方式，遍历所有的 li 来添加事件，这样的问题是添加到页面上的事件处理函数数量与页面整体运行性能挂钩，因为需要不断地与 dom 进行交互，引起的浏览器重绘和重排就越多，会延长整个页面的交互就绪时间，再者每个函数都是一个对象，对象就会占用内存，内存占用率越大性能就会越差。使用事件委托与 dom 操作就只需要操作一次，可以提高性能和节约内存空间。</li></ul><h3>2. 跨域</h3><p>       <strong>面试题：什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求吗？</strong></p><p>       浏览器处于安全考虑有同源策略。协议、域名、端口有一个不同就是跨域，请求会失败。主要是用来防止 CSRF（Cross-site request forgery）攻击，简单来说是利用用户的登录状态发起恶意请求。       session 的理解：例如有一张会员卡，可以享受一些会员权利，会员卡是客户的唯一标识，会员卡卡号就是保存在 cookie 的 sessionId，会员卡权利和个人信息就是服务端的 session 对象。http 请求是无状态的，但是每次 http 请求都会将本域名下的所有 cookie 作为 http 请求头的一部分发送给服务端，所以服务端就根据请求中的 cookie 中的 sessionId 去 session 对象中查找用户信息了。       CSRF 攻击的主要目的是让用户在不知情的情况下攻击自己已登录的一个系统，例如在网站中点击一个图片就会构造一个去论坛发帖的请求，去你的论坛发帖，由于你的浏览器状态是登录的，所以 session 登录的 cookie 信息都会和正常的请求一样。       防御可以通过 referer、token 或者验证码检测用户提交，不要在链接中暴露用户信息，使用 post 操作，严格设置 cookie 的域。       请求跨域后，请求发出去了，但是浏览器拦截了响应。通过表单可以发起跨域请求，因为表单不会获取新的内容，但是 ajax 可以获取响应，所以 ajax 不可以发起跨域请求。所以说明跨域限制并不能完全阻止 CSRF，因为请求已经发出去了。       <strong>如何解决跨域的问题？</strong></p><h4>同源策略限制下接口请求的方式</h4><ol><li>JSONP       在 HTML 标签中，script、img 这样获取资源的标签是没有跨域限制的，所以利用这一点，我们可以通过 script 标签指向一个需要访问的地址并提供一个回调函数来接收数据，不过 script 加载资源是 GET 请求，如果要使用 POST 请求，可以用空 iframe+form。</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//callback是前后端约定的方法名，后端返回一个直接执行的方法给前端，由于是用script标签发起的请求，所以返回方法后立即执行，并且把要返回的数据放在方法的参数里</span></span><br><span class="line">&lt;script src=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>       做一个简单的封装：</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* JSONP请求工具</span></span><br><span class="line"><span class="comment">* @param url 请求的地址</span></span><br><span class="line"><span class="comment">* @param data 请求的参数</span></span><br><span class="line"><span class="comment">* @returns &#123;Promise&lt;any&gt;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="function">(<span class="params">&#123;url, data&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理传参成xx=yy&amp;aa=bb的形式</span></span><br><span class="line">    <span class="keyword">const</span> handleData = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">      <span class="keyword">const</span> keysLen = keys.length</span><br><span class="line">      <span class="keyword">return</span> keys.reduce(<span class="function">(<span class="params">pre, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = data[cur]</span><br><span class="line">        <span class="keyword">const</span> flag = index !== keysLen - <span class="number">1</span> ? <span class="string">'&amp;'</span> : <span class="string">''</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;pre&#125;</span><span class="subst">$&#123;cur&#125;</span>=<span class="subst">$&#123;value&#125;</span><span class="subst">$&#123;flag&#125;</span>`</span></span><br><span class="line">      &#125;, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态创建script标签</span></span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">    <span class="comment">// 接口返回的数据获取</span></span><br><span class="line">    <span class="built_in">window</span>.jsonpCb = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(script)</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">window</span>.jsonpCb</span><br><span class="line">      resolve(res)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;handleData(data)&#125;</span>&amp;cb=jsonpCb`</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">'http://localhost:9871/api/jsonp'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="comment">// 传参</span></span><br><span class="line">    msg: <span class="string">'helloJsonp'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ol start="2"><li>CORS       CORS 是一个 W3C 标准，全称是“跨域资源共享”(cross-origin resource sharing)。只要服务器实现了 CORS 接口，就可以跨域通信，都是浏览器自动完成。       浏览器将 CORS 请求分为两类：简单请求和非简单请求。       同时满足以下两大条件，就属于简单请求：</li></ol><ul><li>请求方法是以下三种方法之一： HEAD GET POST</li><li>http 的头信息不超出以下几种字段：Accept Accept-Language Content-Language Last-Event-ID Content-Type(只限于 application/x-www-form-urlencoded、mutipart/form-data、text/plain)       不同时满足以上两个条件就属于非简单请求。</li></ul><h4>简单请求</h4><p>       浏览器发现跨域的 AJAX 请求是简单请求，就自动在头信息之中加一个 Origin 字段，用来说明请求源（协议+域名+端口），服务器根据这个值决定是否同意这次请求。       如果 Origin 指定的源不在许可范围内，服务器会返回一个正常的 HTTP 回应，浏览器发现回应的头没有包含 Access-Control-Allow-Origin 字段就知道出错了，从而抛出错误。</p><h4>非简单请求</h4><p>       非简单请求是对服务器有特殊要求的请求，比如请求方法是 PUT/DELETE，或者 Content-Type 字段类型是 application/json。       非简单请求的 CORS 请求，会在正式通信前增加一次 HTTP 查询请求，称为“预检”请求。浏览器先询问服务器，当前域名是否在服务器的许可名单中，以及可以使用哪些 HTTP 动词和头信息字段，只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则报错。       一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。</p><ol start="3"><li>代理       使用 Nginx 配置来把请求转发到真正的后端域名上。</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    # 监听9099端口</span><br><span class="line">    listen <span class="number">9099</span>;</span><br><span class="line">    # 域名是localhost</span><br><span class="line">    server_name localhost;</span><br><span class="line">    #凡是localhost:9099/api，都转发到真正的服务端地址http://localhost:9871</span><br><span class="line">    location ^~ <span class="regexp">/api &#123;</span></span><br><span class="line"><span class="regexp">        proxy_pass http:/</span><span class="regexp">/localhost:9871;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>       如果后端接口是公共 API，调用时就不能去配 Nginx，CORS 才是通用的做法。</p><h4>同源策略限制下 Dom 查询的方式</h4><ol><li>postMessage()       它是 H5 的一个接口，用来实现不同窗口不同页面的跨域通讯。</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送方</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 这里一定要对来源做校验</span></span><br><span class="line">  <span class="keyword">if</span> (e.origin === <span class="string">'http://crossdomain.com:9099'</span>) &#123;</span><br><span class="line">    <span class="comment">// 来自http://crossdomain.com:9099的结果回复</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 向http://crossdomain.com:9099发消息</span></span><br><span class="line">postMessage () &#123;</span><br><span class="line">  <span class="keyword">const</span> iframe = <span class="built_in">window</span>.frames[<span class="string">'crossDomainIframe'</span>]</span><br><span class="line">  iframe.postMessage(<span class="string">'我是[http://localhost:9099], 麻烦你查一下你那边有没有id为app的Dom'</span>, <span class="string">'http://crossdomain.com:9099'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收方</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 这里一定要对来源做校验</span></span><br><span class="line">  <span class="keyword">if</span> (e.origin === <span class="string">'http://localhost:9099'</span>) &#123;</span><br><span class="line">    <span class="comment">// http://localhost:9099发来的信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.data)</span><br><span class="line">    <span class="comment">// e.source可以是回信的对象，其实就是http://localhost:9099窗口对象(window)的引用</span></span><br><span class="line">    <span class="comment">// e.origin可以作为targetOrigin</span></span><br><span class="line">    e.source.postMessage(<span class="string">`我是[http://crossdomain.com:9099]，我知道了兄弟，这就是你想知道的结果：<span class="subst">$&#123;<span class="built_in">document</span>.getElementById(<span class="string">'app'</span>) ? <span class="string">'有id为app的Dom'</span> : <span class="string">'没有id为app的Dom'</span>&#125;</span>`</span>, e.origin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ol start="2"><li>document.domain       这种方式只适合主域名相同，但子域名不同的 iframe 跨域。       比如主域名是http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain = crossdomain.com 就可以访问各自的 window 对象了。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;1. 事件机制&lt;/h3&gt;
&lt;p&gt;       &lt;strong&gt;面试题：事件的触发过程是怎么样的？什么是事件代理？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件触发
事件触发的三个阶段：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;从 window 往事件触发处传播，遇到注
      
    
    </summary>
    
      <category term="前端面试之道" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="面试" scheme="github.com/MaTonna/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JS进阶知识点及常考面试题</title>
    <link href="github.com/MaTonna/2019/01/23/JS%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>github.com/MaTonna/2019/01/23/JS进阶知识点及常考面试题/</id>
    <published>2019-01-23T03:52:17.437Z</published>
    <updated>2019-01-23T08:44:23.889Z</updated>
    
    <content type="html"><![CDATA[<h3>1.call、apply 和 bind</h3><p>       <strong>面试题：call、apply 及 bind 函数内部实现是怎么样的？</strong></p><ul><li>定义：调用一个对象的一个方法，用另一个对象代替当前对象</li><li>使用：B.call(A, args1, args2)，B.apply(A, arguments)，<strong>A 对象应用 B 对象的方法</strong></li></ul><p>       实现 call 方法：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new TypeError(&apos;Error&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || window; // 可选参数，不传默认为window</span><br><span class="line">  context.fn = this; //创建fn，此时的this是需要调用的函数，本例中是add()</span><br><span class="line">  const args = [...arguments].slice(1); //剥离参数</span><br><span class="line">  const result = context.fn(...args); //调用函数</span><br><span class="line">  delete context.fn; //将对象上的函数删除</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">function add(a,b)&#123;</span><br><span class="line">  return a+b;</span><br><span class="line">&#125;</span><br><span class="line">function sub(a,b)&#123;</span><br><span class="line">  return a-b;</span><br><span class="line">&#125;</span><br><span class="line">var a1 = add.myCall(sub,4,2); //6，sub调用add的方法</span><br></pre></td></tr></table></figure></p><ul><li>bind()是 ES5 中的方法，<strong>bind 后函数不会立即执行，只是返回一个改变了上下文的函数副本，call 和 apply 是直接执行函数</strong>，ie6~ie8 不支持该方法       实现 bind 方法：</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function (context) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new TypeError(&apos;Error&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  const _this = this;</span><br><span class="line">  const args = [...arguments].slice(1); // argument是类数组，先转成数组再去掉context</span><br><span class="line">  // 返回一个函数</span><br><span class="line">  return function F() &#123;</span><br><span class="line">    // 判断是否是通过new调用函数的，不会被任何方式改变this</span><br><span class="line">    if (this instanceof F) &#123;</span><br><span class="line">      return new _this(...args, ...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    // 因为bind可以实现f.bind(obj, 1)(2)这样的代码，所以需要将参数拼接起来</span><br><span class="line">    return _this.apply(context, args.concat(...arguments)); // 直接调用函数</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>2.new</h3><p>       <strong>面试题：new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别?</strong></p><p>       通过 new 来调用构造函数时，函数体内会发生：</p><ol><li>创建一个空对象，将它的引用赋给 this，并继承函数的原型</li><li>通过 this 将属性和方法添加至这个对象</li><li>最后返回 this 指向的新对象       自己实现一个 new</li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function create() &#123;</span><br><span class="line">  let obj = &#123;&#125;;</span><br><span class="line">  let Con = [...arguments].shift(); // 获取构造函数，例子里是t()函数</span><br><span class="line">  obj.__proto__ = Con.prototype; // 设置空对象的原型，例子里是t()函数的prototype</span><br><span class="line">  let result = Con.apply(obj, arguments); // 绑定this，执行构造函数</span><br><span class="line">  return result instanceof Object ? result : obj; //确保返回值是对象</span><br><span class="line">&#125;</span><br><span class="line">function t() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">let a = create(t);</span><br><span class="line">a; // 打印出1</span><br></pre></td></tr></table></figure></p><p>       字面量优势：</p><ol><li>代码量更少容易阅读</li><li>可以强调对象是一个简单的可变的散列表，不必一定派生自某个类</li><li>对象字面量可以在解析时被优化，不需要“作用域解析”，因为存在你已经创建了一个同名的构造函数 Object()的可能，当调用 Object()的时候，解析器需要顺着作用域链从当前作用域开始查找，找到全局 Object()构造函数为止</li><li>Object()可以接收参数，通过这个参数可以把对象实例的创建过程委托给另一个内置构造函数，并返回另一个对象实例，往往不是我们想要的结果</li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 字符串对象</span><br><span class="line">var o = new Object(&quot;I am a string&quot;);</span><br><span class="line">console.log(o.constructor === String); // true</span><br><span class="line">// 普通对象没有substring()方法，但字符串对象有</span><br><span class="line">// 最终得到的对象是不同的构造函数生成的</span><br><span class="line">console.log(typeof o.substring); // &quot;function&quot;</span><br></pre></td></tr></table></figure></p><h3>3.instanceof</h3><p>       <strong>面试题：instanceof 的原理是什么？</strong></p><p>       instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  let prototype = right.prototype;  // 获取类型的原型</span><br><span class="line">  left = left.__proto__; // 获得对象的原型</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (left === null || left === undefined)</span><br><span class="line">      return false; // 原型链最终为null，所以搜索到对象原型为null为止</span><br><span class="line">    if (prototype === left)</span><br><span class="line">      return true;</span><br><span class="line">    left = left.__proto__; // 向原型链上一层查找</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function a() &#123;&#125;</span><br><span class="line">myInstanceof(a,Function); // true</span><br><span class="line">let b = [1,2,3]</span><br><span class="line">myInstanceof(b,Array); // true</span><br></pre></td></tr></table></figure></p><h3>3.数字精度问题</h3><p>       <strong>面试题：为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</strong></p><p>        0.1 在二进制中是无限循环的一些数字，不只是 0.1，JS 采用的 IEEE 754 双精度版本（64 位）的浮点数标准会裁减掉数字，0.1 就会变成 0.100000000000000002，同样的 0.2 在二进制中也是无限循环的，所以相加不是 0.3。        为什么 console.log(0.1)是正确的？因为在输入内容的时候二进制转换为了十进制，然后再转为字符串，这个转换的过程中取了近似值。       做计算时可以调用如下的函数：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">floatAdd: function(arg1, arg2) &#123;</span><br><span class="line">  var r1, r2, m;</span><br><span class="line">  try &#123;</span><br><span class="line">    r1 = (&apos;&apos; + arg1).split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    r1 = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    r2 = (&apos;&apos; + arg2).split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    r2 = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  m = Math.pow(10, Math.max(r1, r2));</span><br><span class="line">  return (arg1 * m + arg2 * m) / m;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">floatSub: function(arg1, arg2) &#123;</span><br><span class="line">  var r1, r2, m, n;</span><br><span class="line">  try &#123;</span><br><span class="line">    r1 = (&apos;&apos; + arg1).split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    r1 = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    r2 = (&apos;&apos; + arg2).split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    r2 = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  m = Math.pow(10, Math.max(r1, r2));</span><br><span class="line">  //动态控制精度长度</span><br><span class="line">  n = r1 &gt;= r2 ? r1 : r2;</span><br><span class="line">  return ((arg1 * m - arg2 * m) / m).toFixed(n);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//浮点数乘法运算</span><br><span class="line">floatMul: function(arg1, arg2) &#123;</span><br><span class="line">  var m = 0,</span><br><span class="line">    s1 = &apos;&apos; + arg1,</span><br><span class="line">    s2 = &apos;&apos; + arg2;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    m += s1.split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;&#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    m += s2.split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;&#125;</span><br><span class="line">  return (</span><br><span class="line">    Number(s1.replace(&apos;.&apos;, &apos;&apos;)) *</span><br><span class="line">    Number(s2.replace(&apos;.&apos;, &apos;&apos;)) /</span><br><span class="line">    Math.pow(10, m)</span><br><span class="line">  );</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//浮点数除法运算</span><br><span class="line">floatDiv: function(arg1, arg2) &#123;</span><br><span class="line">  var t1 = 0,</span><br><span class="line">    t2 = 0,</span><br><span class="line">    r1,</span><br><span class="line">    r2;</span><br><span class="line">  try &#123;</span><br><span class="line">    t1 = (&apos;&apos; + arg1).split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;&#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    t2 = (&apos;&apos; + arg2).split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  r1 = Number((&apos;&apos; + arg1).replace(&apos;.&apos;, &apos;&apos;));</span><br><span class="line">  r2 = Number((&apos;&apos; + arg2).replace(&apos;.&apos;, &apos;&apos;));</span><br><span class="line">  return r1 / r2 * Math.pow(10, t2 - t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;1.call、apply 和 bind&lt;/h3&gt;
&lt;p&gt;       &lt;strong&gt;面试题：call、apply 及 bind 函数内部实现是怎么样的？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义：调用一个对象的一个方法，用另一个对象代替当前对象&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="前端面试之道" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="面试" scheme="github.com/MaTonna/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Event Loop</title>
    <link href="github.com/MaTonna/2019/01/22/Event%20Loop/"/>
    <id>github.com/MaTonna/2019/01/22/Event Loop/</id>
    <published>2019-01-22T08:30:02.215Z</published>
    <updated>2019-04-25T12:16:23.324Z</updated>
    
    <content type="html"><![CDATA[<h3>1.进程与线程</h3><p>       <strong>面试题：进程与线程区别？JS 单线程带来的好处？</strong></p><ul><li>进程：描述了 CPU 在运行指令及加载和保存上下文所需的时间</li><li>线程：是进程中的更小单位，描述了执行一段执行所需的时间</li></ul><p>       当在浏览器打开一个 Tab 页时，就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。</p><p>       JS 单线程可以达到节省内存，节约上下文切换时间、没有锁的问题的好处。在 JS 运行时可能会阻止 UI 渲染，说明两个线程是互斥的，避免 JS 修改 DOM 的时候 UI 线程在工作就可能导致不能安全渲染 UI。</p><h3>2.执行栈</h3><p>       <strong>面试题：什么是执行栈？</strong></p><p>       可以理解为是一个存储函数调用的栈结构，遵循先进后出的原则。</p><p>       当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈。</p><p>       当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现栈溢出的问题<img src="/img/content/functionStack.gif" alt="执行栈示意图"></p><h3>3.浏览器中的 Event Loop</h3><p>       <strong>面试题：异步代码执行顺序？解释一下什么是 Event Loop ？</strong></p><p>       执行 JS 代码的时候其实就是往执行栈中放入函数，遇到异步代码时，会被<strong>挂起</strong>并在需要的时候加入到 Task 队列中。执行栈为空，Event Loop 就会从 Task 队列拿出需要执行的代码并放入执行栈中执行。</p><ul><li>宏任务包括 ：<strong>script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering</strong>。</li><li>微任务包括 ：<strong>process.nextTick ，promise ，MutationObserver</strong>。       例子：</li></ul><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>) <span class="comment">// 5，相当于在Primise的then中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>) <span class="comment">// 2，返回一个Promise</span></span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>) <span class="comment">// 8</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>) <span class="comment">// 3</span></span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>) <span class="comment">// 6</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>) <span class="comment">// 7</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>) <span class="comment">// 4，同步执行完毕</span></span><br></pre></td></tr></table></figure></p><p>所以 Event Loop 执行顺序如下所示：</p><ol><li>首先执行同步代码，这属于宏任务</li><li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li><li>执行所有微任务</li><li>当执行完所有微任务后，如有必要会渲染页面</li><li>然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数</li></ol><p><img src="/img/content/eventloop.png" alt="复杂的Event Loop执行顺序示意"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;1.进程与线程&lt;/h3&gt;
&lt;p&gt;       &lt;strong&gt;面试题：进程与线程区别？JS 单线程带来的好处？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程：描述了 CPU 在运行指令及加载和保存上下文所需的时间&lt;/li&gt;
&lt;li&gt;线程：是进程中的更小单位，描述了执行
      
    
    </summary>
    
      <category term="前端面试之道" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="面试" scheme="github.com/MaTonna/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>实现一个Promise</title>
    <link href="github.com/MaTonna/2019/01/22/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAPromise/"/>
    <id>github.com/MaTonna/2019/01/22/实现一个Promise/</id>
    <published>2019-01-22T07:04:24.302Z</published>
    <updated>2019-04-25T12:17:14.554Z</updated>
    
    <content type="html"><![CDATA[<ul><li>简易版 Promise</li></ul><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span>; <span class="comment">// 代码可能会异步执行，用于获取正确的this对象</span></span><br><span class="line">  that.state = PENDING;</span><br><span class="line">  that.value = <span class="literal">null</span>; <span class="comment">// 用于保存resolve或者reject中传入的值</span></span><br><span class="line">  that.resolvedCallbacks = [];</span><br><span class="line">  that.rejectedCallbacks = []; <span class="comment">// 保存then中的回调，状态改变时使用</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//只有等待状态才可以改变状态</span></span><br><span class="line">    <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">      that.state = RESOLVED;</span><br><span class="line">      that.value = value; <span class="comment">// 调用then的时候value需要往下传递</span></span><br><span class="line">      that.resolvedCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(that.value)); <span class="comment">// 执行回调</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">      that.state = REJECTED;</span><br><span class="line">      that.value = value;</span><br><span class="line">      that.rejectedCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(that.value));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行Promise中传入的函数</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 检测参数是否是函数类型，如果不是则创建一个函数赋值给对应的参数</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(r);</span><br><span class="line">        &#125;;</span><br><span class="line">  <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">    that.resolvedCallbacks.push(onFulfilled);</span><br><span class="line">    that.rejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (that.state === RESOLVED) &#123;</span><br><span class="line">    onFulfilled(that.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === REJECTED) &#123;</span><br><span class="line">    onRejected(that.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">1</span>) &#123;</span><br><span class="line">    resolve(a);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="string">'error啦'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(</span><br><span class="line">  value =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err'</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><ul><li>完整版 Promise(https://github.com/xieranmaya/blog/issues/2)<strong>通过了 promises-aplus-tests 的测试</strong>npm i -g promises-aplus-testspromises-aplus-tests Promise.js</li></ul><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  self.status = <span class="string">'pending'</span>;</span><br><span class="line">  self.onResolvedCallback = [];</span><br><span class="line">  self.onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 异步执行所有的回调函数</span></span><br><span class="line">      <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        self.status = <span class="string">'resolved'</span>;</span><br><span class="line">        self.data = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line">          self.onResolvedCallback[i](value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 异步执行所有的回调函数</span></span><br><span class="line">      <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        self.status = <span class="string">'rejected'</span>;</span><br><span class="line">        self.data = reason;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line">          self.onRejectedCallback[i](reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> then;</span><br><span class="line">  <span class="keyword">var</span> thenCalledOrThrow = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Chaining cycle detected for promise!'</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">//because x could resolved by a Promise Object</span></span><br><span class="line">      x.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        resolvePromise(promise2, v, resolve, reject);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//but if it is resolved, it will never resolved by a Promise Object but a static value;</span></span><br><span class="line">      x.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      then = x.then; <span class="comment">//because x.then could be a getter</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">rs</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span>;</span><br><span class="line">            thenCalledOrThrow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">rj</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span>;</span><br><span class="line">            thenCalledOrThrow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> reject(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span>;</span><br><span class="line">      thenCalledOrThrow = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> promise2;</span><br><span class="line">  onResolved =</span><br><span class="line">    <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span></span><br><span class="line">      ? onResolved</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> v;</span><br><span class="line">        &#125;;</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> r;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 异步执行onResolved</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.data);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 异步执行onRejected</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onRejected(self.data);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onResolvedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onRejected(reason);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.deferred = <span class="built_in">Promise</span>.defer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dfd = &#123;&#125;;</span><br><span class="line">  dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    dfd.resolve = resolve;</span><br><span class="line">    dfd.reject = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;简易版 Promise&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s
      
    
    </summary>
    
      <category term="前端面试之道" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="面试" scheme="github.com/MaTonna/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JS 异步编程及常考面试题</title>
    <link href="github.com/MaTonna/2019/01/19/JS%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>github.com/MaTonna/2019/01/19/JS 异步编程及常考面试题/</id>
    <published>2019-01-19T06:51:47.240Z</published>
    <updated>2019-04-25T12:16:47.744Z</updated>
    
    <content type="html"><![CDATA[<h3>1. 回调函数</h3><p>       <strong>面试题：回调函数有什么缺点？如何解决回调地狱问题？</strong></p><p>       回调容易写出回调地狱，根本问题是嵌套函数存在耦合性，一旦有所改动就会牵一发而动全身，并且嵌套函数多了会很难处理错误。回调函数不能使用 try catch 捕获错误，不能直接 return。</p><p>       <strong>如何解决回调地狱的问题？：用 Generator/Promise/async&amp;&amp;await 来改善。</strong></p><h3>2. Generator</h3><p>       <strong>面试题：你理解的 Generator 是什么？？</strong></p><p>       Generator 是生成器，一种返回迭代器（是一种特殊对象，具有一些专门为迭代过程设计的专有接口，所有的迭代器对象都有 next()方法，每次调用都会返回结果对象{value:'xxx',done:true/false}）的函数，用处是可以控制函数的执行，通过 function 关键字后的*来表示，函数中会使用 yield 关键字。</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// 执行yield(x+1) =&gt; 输出&#123;value:6, done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)); <span class="comment">// 执行yield(y/3)，传入的12是上一个yield的返回值（如果不传参数，上一个yield是undefined），即 yield(x+1) = 12 =&gt; y = 2*12 = 24; =&gt; 输出yield(y/3) = &#123;value:8, done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)); <span class="comment">// 执行x+y+z，输入的13是yield(y/3) =&gt; z = 13 =&gt; 输出x+y+z = 5+24+13 = 42</span></span><br></pre></td></tr></table></figure></p><p>       使用 Generator 来解决回调地狱的问题：</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> ajax(url1 ,() =&gt; &#123;&#125;)</span><br><span class="line">  <span class="keyword">yield</span> ajax(url2 ,() =&gt; &#123;&#125;)</span><br><span class="line">  <span class="keyword">yield</span> ajax(url3 ,() =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch();</span><br><span class="line"><span class="keyword">let</span> result1 = it.next();</span><br><span class="line"><span class="keyword">let</span> result2 = it.next();</span><br><span class="line"><span class="keyword">let</span> result3 = it.next();</span><br></pre></td></tr></table></figure></p><h3>3.Promise</h3><p>       <strong>面试题：Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？</strong></p><ol><li>特点和优缺点：</li></ol><ul><li>Promise 有三种状态：等待中(pending)、完成了(resolved)、拒绝了(rejected)，一旦从等待状态变成了其他状态就不能更改状态了</li></ul><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">  reject(<span class="string">'reject'</span>) <span class="comment">// 无效</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>在构造 Promise 的时候，构造函数内部的代码是立即执行的</li></ul><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'new Promise'</span>);</span><br><span class="line">  resolve(<span class="string">'success'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'finish'</span>);</span><br><span class="line"><span class="comment">// new Promise -&gt; finish</span></span><br></pre></td></tr></table></figure></p><p>       缺点：无法取消 Promise，错误需要通过回调函数捕获。</p><ol start="2"><li><p>Promise 实现了链式调用，每次调用 then 之后返回一个<strong>全新的</strong>Promise（因为状态不可变），如果在 then 中使用了 return，那么 return 的值会被 Promise.resolve()包装。</p></li><li><p>使用 Promise 来解决回调地狱的问题：</p></li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ajax(url)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">return</span> ajax(url1)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">return</span> ajax(url2)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h3>4.async 及 await</h3><p>       <strong>面试题：async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？</strong></p><ul><li>await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator。一个函数如果加上 async，那么函数就会返回一个 Promise，async 就是将函数返回值用 RESOLVE 包裹了，和 then 中处理返回值一样，并且 await 只能配套 async 使用</li><li>相比于直接使用 Promise，处理掉了 then 的调用链，优雅的解决了回调地狱的问题</li></ul><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式</span></span><br><span class="line">  <span class="comment">// 如果有依赖性的话，其实就是解决回调地狱的例子了</span></span><br><span class="line">  <span class="keyword">await</span> fetch(url)</span><br><span class="line">  <span class="keyword">await</span> fetch(url1)</span><br><span class="line">  <span class="keyword">await</span> fetch(url2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>缺点：await 将异步代码改造成了同步代码，如果多个异步没有依赖性，使用了 await 会导致性能上的降低。(一个执行完成才会执行下一个)<img src="/img/content/await.png" alt="await例子"></p><p>       await 创建 promise，所以 await 之后的代码才是异步的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;1. 回调函数&lt;/h3&gt;
&lt;p&gt;       &lt;strong&gt;面试题：回调函数有什么缺点？如何解决回调地狱问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       回调容易写出回调地狱，根本问题是嵌套函数存在耦合性，一旦有所改动就会牵一发而动全身，并且嵌套函数多了会很难处理错
      
    
    </summary>
    
      <category term="前端面试之道" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="面试" scheme="github.com/MaTonna/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ES6知识点及常考面试题</title>
    <link href="github.com/MaTonna/2019/01/17/ES6%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>github.com/MaTonna/2019/01/17/ES6知识点及常考面试题/</id>
    <published>2019-01-17T02:18:27.671Z</published>
    <updated>2019-01-17T08:16:20.017Z</updated>
    
    <content type="html"><![CDATA[<h3>1. var、let 及 const 区别</h3><p>       <strong>面试题：什么是提升？什么是暂时性死区？var、let 及 const 区别？</strong></p><p>       在变量声明之前使用变量叫做变量提升，并且提升的是声明，使用 var 声明的变量会被提升到作用域的顶部。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var a ;</span><br><span class="line">console.log(a) //10</span><br><span class="line">//相当于</span><br><span class="line">var a;</span><br><span class="line">var a;</span><br><span class="line">a = 10;</span><br></pre></td></tr></table></figure></p><p>       函数也会被提升，并且优于变量提升，函数提升会把整个函数挪到作用域顶部。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">let b = 1</span><br><span class="line">const c = 1</span><br><span class="line">console.log(window.a)  // 1</span><br><span class="line">console.log(window.b)  // undefined</span><br><span class="line">console.log(window. c) // undefined</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">  let a</span><br><span class="line">&#125;</span><br><span class="line">test() // 报错：a is not defined</span><br></pre></td></tr></table></figure></p><p>       总结：</p><ul><li>let 和 const 存在暂时性死区，不能在声明前使用变量</li><li>在全局作用域下使用 let 和 const 声明变量，变量不会被挂载到 window 上</li><li>let 和 const 声明变量使用的是块作用域</li><li>let 和 const 不允许重复定义</li><li>let 在循环中引入了新的环境变量，针对每次迭代都会创建新的作用域</li><li>const 声明的变量不能再次赋值</li></ul><h3>2. 原型继承和 class 继承</h3><p>       <strong>面试题：原型如何实现继承？Class 如何实现继承？Class 本质是什么？</strong></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//父类</span><br><span class="line">function Parent(value) &#123;</span><br><span class="line">  this.val = value;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = function() &#123;</span><br><span class="line">  console.log(this.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>组合继承</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Child(value) &#123;</span><br><span class="line">  Parent.call(this, value); //在子类的构造函数中继承父类的属性</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent(); //改变子类的原型为new Parent()来继承父类的函数</span><br><span class="line">const child = new Child(1);</span><br><span class="line"></span><br><span class="line">child.getValue(); // 1</span><br><span class="line">child instanceof Parent // true</span><br></pre></td></tr></table></figure></p><p>       缺点：继承父类函数时调用了父类构造函数，导致子类的原型上多了不需要的父类属性，内存上存在浪费。</p><ul><li>寄生组合继承</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Child(value) &#123;</span><br><span class="line">  Parent.call(this, value);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = Object.create(Parent.prototype, &#123;</span><br><span class="line">  constructor:&#123;</span><br><span class="line">    value: Child, // 将父类的原型赋给子类，将构造函数设置为子类</span><br><span class="line">    enumerable: false,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>class 继承</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Parent &#123;</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line">    super(value); // 必须调用，继承父类属性，相当于Parent.call(this, value)</span><br><span class="line">    this.val = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>       class 本质是函数，JS 中并不存在类</p><h3>3. 模块化</h3><p>       <strong>面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？</strong></p><p>       优点：解决命名冲突、提供复用性、提高代码可维护性       实现模块化的方式：</p><ul><li>立即执行函数</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(globalVariable) &#123;</span><br><span class="line">  // 声明各种变量、函数都不会污染全局作用域</span><br><span class="line">&#125;)(globalVariable)</span><br></pre></td></tr></table></figure></p><ul><li>AMD/CMD</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// AMD</span><br><span class="line">define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123;</span><br><span class="line">  // 加载模块完毕可以使用</span><br><span class="line">  a.do()</span><br><span class="line">  b.do()</span><br><span class="line">&#125;)</span><br><span class="line">// CMD</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  // 加载模块</span><br><span class="line">  // 可以把 require 写在函数体的任意地方实现延迟加载</span><br><span class="line">  var a = require(&apos;./a&apos;)</span><br><span class="line">  a.doSomething()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>CommonJS</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  a: 1</span><br><span class="line">&#125;</span><br><span class="line">// or</span><br><span class="line">exports.a = 1</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">var module = require(&apos;./a.js&apos;)</span><br><span class="line">module.a // -&gt; log 1</span><br></pre></td></tr></table></figure></p><ul><li>ES Module</li></ul><ol><li>异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>会编译成 require/exports 来执行的</li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 引入模块 API</span><br><span class="line">import XXX from &apos;./a.js&apos;</span><br><span class="line">import &#123; XXX &#125; from &apos;./a.js&apos;</span><br><span class="line">// 导出模块 API</span><br><span class="line">export function a() &#123;&#125;</span><br><span class="line">export default function() &#123;&#125;</span><br></pre></td></tr></table></figure></p><h3>4. Proxy</h3><p>       <strong>面试题：Proxy 可以实现什么功能？</strong></p><p>       解释：</p><ol><li>代理（Proxy）是一种可以拦截并改变底层 JavaScript 引擎操作的包装器，通过暴露内部运作的对象，从而可以创建内建的对象</li><li>底层被拦截后会触发响应特定操作的陷阱函数</li><li>反射 API 以 Reflect 对象的形式存在，Reflect 对象中的方法的默认特性和相同的底层操作保持一致，代理可以覆写这些操作，每个代理陷阱对应一个命名和参数都相同的 Reflect 方法</li><li>代理和反射的关系举例：改写内置 get 方法，代理负责拦截原来的 get 方法，并触发陷阱函数修改 get 的读取属性值特性，反射就是原来的内置方法，即 Reflect.get()是之前的 get 方法       使用 set 陷阱验证属性：</li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let target = &#123;</span><br><span class="line">  name: &quot;target&quot;</span><br><span class="line">&#125;</span><br><span class="line">let proxy = new Proxy(target, &#123;</span><br><span class="line">  //set陷阱</span><br><span class="line">  set(trapTarget, key, value, receiver) &#123;</span><br><span class="line">    //忽略已有属性</span><br><span class="line">    if(!trapTarget.hasOwnProperty(key)) &#123;</span><br><span class="line">      if(isNaN(value)) &#123;</span><br><span class="line">        throw new TypeError(&apos;属性必须为数字&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Reflect.set(trapTarget, key, value, receiver); //反射，用于使用内置set方法添加属性</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.count = 1; // 此时set陷阱被调用，是数字所以可以赋值</span><br><span class="line">console.log(target.count) // 1</span><br><span class="line">proxy.name = &apos;proxy&apos;;</span><br><span class="line">console.log(target.name) // &apos;proxy&apos;，target已有name属性，所以可以赋值</span><br><span class="line">proxy.notNumber = &apos;a&apos;; // Uncaught TypeError: 属性必须为数字，给不存在的属性赋值并且值不是数字则抛错</span><br></pre></td></tr></table></figure></p><p>       实现简单版响应式：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">let onWatch = (obj, setBind, getLogger) =&gt; &#123;</span><br><span class="line">  let handler = &#123;</span><br><span class="line">    //set陷阱</span><br><span class="line">    set(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value, property)</span><br><span class="line">      return Reflect.set(target, property, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    //get陷阱</span><br><span class="line">    get(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      return Reflect.get(target, property, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return new Proxy(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123; a: 1 &#125;</span><br><span class="line">let p = onWatch(</span><br><span class="line">  obj,</span><br><span class="line">  (v, property) =&gt; &#123;</span><br><span class="line">    console.log(`监听到属性$&#123;property&#125;改变为$&#123;v&#125;`)</span><br><span class="line">  &#125;,</span><br><span class="line">  (target, property) =&gt; &#123;</span><br><span class="line">    console.log(`&apos;$&#123;property&#125;&apos; = $&#123;target[property]&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">p.a = 2 // 监听到属性a改变</span><br><span class="line">p.a // &apos;a&apos; = 2</span><br></pre></td></tr></table></figure></p><p>       应用举例：用 get 陷阱验证对象结构、用 has 陷阱隐藏已有属性、用 deleteProperty 陷阱防止删除属性</p><h3>4. 数组方法</h3><p>       <strong>面试题：map, filter, reduce 各自有什么作用？</strong></p><ul><li>map：[].map((当前索引元素，索引，原数组) =&gt; {})，遍历原数组，每个元素做相同的操作，生成一个新数组</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].map(v =&gt; v + 1) // -&gt; [2, 3, 4]</span><br></pre></td></tr></table></figure></p><ul><li>filter：[].filter((当前索引元素，索引，原数组) =&gt; {})，遍历原数组时将返回 true 的元素放入新数组</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let newArray = [1, 2, 4, 6].filter(item =&gt; item !== 6) // [1,2,4]</span><br></pre></td></tr></table></figure></p><ul><li>reduce：[].reduce((累计值、当前元素、当前索引、原数组) =&gt; {}, 初始值)，将数组中的元素通过回调函数最终转换为一个值</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入</span><br><span class="line">const sum = [1, 2, 3].reduce((acc, current) =&gt; acc + current, 0) // 累加为6</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;1. var、let 及 const 区别&lt;/h3&gt;
&lt;p&gt;       &lt;strong&gt;面试题：什么是提升？什么是暂时性死区？var、let 及 const 区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在变量声明之前使用变量叫做变量提升，并且提升的是声明，使用
      
    
    </summary>
    
      <category term="前端面试之道" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="面试" scheme="github.com/MaTonna/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JS基础知识及常考面试题</title>
    <link href="github.com/MaTonna/2019/01/16/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>github.com/MaTonna/2019/01/16/JS基础知识及常考面试题/</id>
    <published>2019-01-16T03:51:50.962Z</published>
    <updated>2019-01-24T06:17:26.869Z</updated>
    
    <content type="html"><![CDATA[<h3>1. 数据类型</h3><ul><li><p>原始（Primitive）类型       <strong>面试题：原始类型有哪几种？null 是对象吗？</strong></p><p>       原始类型种类：boolean、number、string、null、undefined、symbol       原始类型存储的都是值，没有函数可以调用，true.toString()会强制转换成对象 String 类型       typof null 输出 object，但是是 JS 的一个 bug，最初设计使用 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象， null 表示全为 0，所以误判为 object。</p></li><li><p>对象（Object）类型       <strong>面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？</strong></p><p>       原始类型存储的是值，对象类型存储的是地址（指针）。当我们将变量赋值给另一个变量时，复制的是原本变量的地址（指针），所以数据修改时，是修改存放在该地址（指针）上的值，导致两个变量的值都发生了变化。       函数传参是传递对象指针的副本，形参会被重新分配一个新的地址（指针），就和原本的对象没有关系了，两个变量的值就不同。</p></li><li><p>类型判断       <strong>面试题：typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？</strong></p><p>       typeof 除了 null 之外都可以显示正确的类型，typeof null 为 object，typeof 除了函数的对象，都会显示 object，typeof 函数会显示 function，所以 typeof 不能准确判断变量的类型。       instanceof 是通过原型链来判断对象的正确类型的，但是不能直接通过 instanceof 来判断原始类型，但是可以通过 Symbol.hasInstance 来改造。</p></li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class PrimitiveString &#123;</span><br><span class="line">  static [Symbol.hasInstance](x) &#123;</span><br><span class="line">    return typeof x === &apos;string&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;hello world&apos; instanceof PrimitiveString) // true</span><br></pre></td></tr></table></figure></p><ul><li><p>类型转换       原始类型之间转换：转换为布尔值、转换为数字、转换为字符串<img src="/img/content/type-trans.png" alt="类型转换表"></p><p><strong>注：在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。</strong></p><p>       对象转原始类型：会调用内置的 [[ToPrimitive]] 函数，该函数会优先调用 valueOf 方法，如果转换为基础类型就返回转换后的值，否则调用 toString 方法，如果两种方法都没有返回原始类型，则抛错。(可以重写 Symbol.toPrimitive 方法，该方法在转原始类型时调用的优先级最高)</p><p>       toString()与 valueOf()的差别：</p><ul><li>toString()将数据转换成相应的字符串形式，参考类型转换表</li><li>valueOf()返回自身的值，比如数组会返回数组，函数会返回函数</li></ul></li></ul><h3>2.四则运算符</h3><ul><li><p>加法运算符：       如果其中一方是字符串，就把另一方也转换为字符串，例：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + &apos;1&apos; -&gt; &apos;11&apos;</span><br></pre></td></tr></table></figure></p><p>       如果一方不是字符串或数字，就将它转换成数字或字符串，例：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true + true -&gt; 2</span><br><span class="line">4 + [1,2,3] -&gt; &apos;41,2,3&apos;</span><br></pre></td></tr></table></figure></p><p>       一元加法运算，快速获取 number 类型，例：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+&apos;1&apos; -&gt; 1</span><br><span class="line">&apos;a&apos; + + &apos;b&apos; -&gt; &apos;aNaN&apos;</span><br></pre></td></tr></table></figure></p></li></ul><ul><li>其他的运算符：       只要其中一方是数字，另一方就转为数字</li></ul><p><strong>注：如果{}被放在运算符最前面，会当做代码块处理,如果{}被放在运算中，那么他首先会调用 toString 方法</strong></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; + [] =&gt; 0</span><br><span class="line">[] + &#123;&#125; =&gt; &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure></p><h3>3.比较运算符</h3><p>       如果是对象，通过 toPrimitive 转换对象，具体调用规则看上面的类型转换       如果是字符串，通过 unicode 字符索引来比较</p><h3>4.this</h3><p>       <strong>面试题：如何正确判断 this？箭头函数的 this 是什么？</strong></p><p>       箭头函数没有 this，箭头函数中的 this 取决于包裹箭头函数的第一个普通函数的 this，就不能用过构造函数。       谁调用了函数，谁就是 this。多个 this 同时出现的情况下，this 的优先级：new foo() &gt; foo.bind() &gt; obj.foo() &gt; foo()<img src="/img/content/this.png" alt="单个规则的this"></p><h3>5.== 和 ===</h3><p>       <strong>面试题：==和===有什么区别？</strong></p><ul><li>== 类型不一样就会进行类型转换，相同就比大小。流程：</li></ul><ol><li>比对双方是否为 null 和 undefined，是则返回 true</li><li>比对双方类型是否为 string 和 number，是则将字符串转为 number，例：</li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 == &apos;1&apos; -&gt; 1 == 1</span><br></pre></td></tr></table></figure></p><ol start="3"><li>比对一方是否为 boolean，是则把 boolean 转为 number，例：</li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;1&apos; == true -&gt; &apos;1&apos; == 1</span><br></pre></td></tr></table></figure></p><ol start="4"><li>判断一方是否为 object，另一方为 string、number、symbol，是则会 object 转为原始类型，例：</li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;1&apos; == &#123; name:&apos;xx&apos; &#125; -&gt; &apos;1&apos; == &apos;[object Object]&apos;</span><br></pre></td></tr></table></figure></p><p><img src="/img/content/check-equal.png" alt="判定流程"></p><p>       思考题： [] == ![]</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![].valueOf() -&gt; false</span><br><span class="line">[].valueOf()  -&gt; []</span><br><span class="line">[] == false   -&gt; true</span><br></pre></td></tr></table></figure></p><ul><li>===判断类型和值是否相同。</li></ul><h3>6. 闭包</h3><p>       <strong>面试题：什么是闭包？如何解决循环中 var 定义函数的问题？</strong></p><p>       定义：**函数 A 的内部有一个函数 B，函数 B 可以访问函数 A 中的变量，函数 B 就是闭包。**函数嵌套函数，返回一个函数，这个解释不完整，看下面的例子：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  let a = 1</span><br><span class="line">  window.B = function () &#123;</span><br><span class="line">      console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() // 1</span><br></pre></td></tr></table></figure></p><p>       经典面试题：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  setTimeout(function timer() &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;, i * 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>       输出全是 6 的原因：setTimeout 是个异步函数，所以 for 先全部执行完毕，再到 event loop 中执行 setTimeout，此时 i 已经是 6 了。解决方法：</p><ul><li>方法 1：使用闭包，用立即执行函数包裹（**关键！**在 for 循环中定义了 5 个定时器，本来 5 个定时器会放到队列里等待执行，由于外面是立即执行函数，就会立即执行，并且把 i 传进去了，等到函数执行的时候，向上查找 i，正好在立即执行函数的作用域里找到了 i）</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  (function(j) &#123;</span><br><span class="line">    setTimeout(function timer() &#123;</span><br><span class="line">      console.log(j)</span><br><span class="line">    &#125;, j * 1000)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  setTimeout((function(i) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i), i * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>方法 2：使用 setTimeout 的第三个参数，当做定时器函数的参数</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  setTimeout(</span><br><span class="line">    function timer(j) &#123;</span><br><span class="line">      console.log(j)</span><br><span class="line">    &#125;,</span><br><span class="line">    i \* 1000,</span><br><span class="line">    i</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>方法 3：使用 let 来定义 i</li></ul><h3>7. 深浅拷贝</h3><p>       <strong>面试题：什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？</strong></p><ul><li>浅拷贝只拷贝对象的第一层，如果接下去的值还有对象，则需要使用深拷贝。</li><li>用 Object.assign 和展开运算符...解决浅拷贝的问题，拷贝所有的属性值到新对象</li><li>实现深拷贝：使用 JSON.parse(JSON.stringify(object))，但是会忽略 undefined、symbol，不能序列化函数，也不能解决循环引用的对象，所以推荐使用 lodash 的深拷贝函数</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj) &#123;</span><br><span class="line">  function isObject(o) &#123;</span><br><span class="line">    return (typeof o === &apos;object&apos; || typeof o === &apos;function&apos;) &amp;&amp; o !== null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!isObject(obj)) &#123;</span><br><span class="line">    throw new Error(&apos;非对象&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let isArray = Array.isArray(obj)</span><br><span class="line">  let newObj = isArray ? [...obj] : &#123; ...obj &#125;</span><br><span class="line">  //Reflect.ownKeys返回所有属性key,Object.keys()返回属性key，但不包括方法属性</span><br><span class="line">  Reflect.ownKeys(newObj).forEach(key =&gt; &#123;</span><br><span class="line">    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>7. 原型</h3><p>       <strong>面试题：如何理解原型？如何理解原型链？</strong></p><p>       每个 JS 对象都有<strong>proto</strong>属性，这个属性实际上是个对象，这个属性指向原型，是为了让我们访问到内部属性 [[prototype]] 。原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型。       prototype 存在的意义是在 function 作为 constructor 用时（new 或 super）能复制到生成对象的<strong>proto</strong>上，对于一些内部方法（比如 toString、Math.max）不会作为 constructor，所以没有 prototype 是合理的（同时也没有[[Construct]]内部属性）       原型链就是多个对象通过<strong>proto</strong>的方式连接了起来，obj 可以访问 valueOf 就是因为 obj 通过原型链找到 Object，从而找到了 valueOf 函数，一个类型的原型对象等于另一个类型的实例，伪代码 Subtype.prototype = new SuperType()。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__proto__ :&#123;</span><br><span class="line">  constructor:&#123;       //constructor指向下面的原型</span><br><span class="line">    prototype:&#123;       //原型的constructor指向构造函数</span><br><span class="line">      constructor:&#123;   //构造函数又通过prototype指向原型</span><br><span class="line">        prototype...  //形成原型链</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;1. 数据类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原始（Primitive）类型
       &lt;strong&gt;面试题：原始类型有哪几种？null 是对象吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       原始类型种类：boolean、number、string、nul
      
    
    </summary>
    
      <category term="前端面试之道" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="面试" scheme="github.com/MaTonna/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>2018年度总结-工作篇</title>
    <link href="github.com/MaTonna/2019/01/03/2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-%E5%B7%A5%E4%BD%9C%E7%AF%87/"/>
    <id>github.com/MaTonna/2019/01/03/2018年度总结-工作篇/</id>
    <published>2019-01-03T06:16:27.188Z</published>
    <updated>2019-01-03T09:43:59.986Z</updated>
    
    <content type="html"><![CDATA[<p>       2018 年结束就代表毕业以及工作一年半了，不管是业务熟练程度还是技术掌握都有了自己感知得到的进步。回顾这一年的工作</p><ul><li><p>接触的浏览器平台也从 web 端，PC 软件内嵌 H5，转到了移动端，有 H5，也有 APP 内嵌 H5，还有微信公众号平台，bug 也各不相同</p></li><li><p>使用的库也从 jquery 转向了 vue+vant 和 react+antd</p></li><li><p>做的产品也有面向用户、面向销售以及面向内部人员</p></li><li><p>写的项目也从简单的后台管理系统到对外客户使用的复杂项目，还有复杂的管理后台系统，抽奖、火箭逐帧动画</p></li><li><p>从只会跟着 PRD 写页面调接口，到自己写一套商城系统，到自己从头主导构建小项目       以上这些都是今年工作上的进步。 </p><p>       除了明显的代码效率和质量上的提高，还有一些心态上的转变，之前很惧怕学习和写 react 项目，担心会因为自己的不熟悉拖延项目进度和降低整体的代码质量，后来由于任务分配而不得不接受要去学习 react 使用的事实（其实一部分是很不喜欢把 html 也写到 js 里，代码整体显得很冗余和笨重）。其实通过组件化来管理自己负责的模块是非常得益的，通过把代码按照模块拆分来其实也降低了复杂度，并且能让自己理清有时非常绕和复杂的需求。 </p><p>       学习的过程非常枯燥和纠结，一方面和自己已掌握的库对比好像又懂了，一方面怀疑自己只会皮毛和简单的使用而不是真正懂他的原理和流程。例如前段时间学习了 redux（博客里有一篇简易的 demo），其实官方的教程有点不是很好理解，然后去找了相关的视频，跟着学习和实践了一次，但是只是单纯的会用，并且记不得调用的过程（只记得简单的应该要建一个 store，然后通过 dispatch 去调用 reducer 里的方法来改变 store 里的值，各个组件通过 connect 共享同一份 store 里的数据，相当于共同的 state，但是并不记得应该如何创建和调用这些流程，每次要写都要去翻之前的代码和教程），后来下定决心搞懂这个 redux 的流程，翻了很多别人的示意图结合之前看的视频，自己画了一个 redux flow 图，这个过程让我想清楚了他的工作流程。并不是说单纯的学到了这个知识点，而是意识到了之前自己的学习方式只是很松散的了解或者使用了一个知识，我也可以认真的去钻研一个点，能够用自己的话讲解并且讲明白这个东西才是真正的懂了。 </p><p>       学习 redux 过了几个礼拜，刚好有个新项目需要我主导负责，并且也负责一整块的需求，其中一个需求是一个带有分组的菜单栏，菜单栏中可以修改分组名，点击展示内容，内容中也可以修改分组和菜单名，我拆分成了几个组件，相互之间传参回调之间特别麻烦，就想改造成 redux 统一管理菜单的信息，之前项目惯例使用 dva，有了前段时间 redux 的知识储备，上手就变得比较简单了，改造起来效率也非常高，还是很有成就感的。 </p><p>       关于负责一个小的新项目，还是有一些感触的。项目在过需求和项目开始之间的空档期，需要考虑技术选型和写基本的公共方法和样式，由于新项目是个数据服务系统，之前参与过别的类似项目，也是沿用之前的那一套 react+antd，但是基本的菜单栏和公共导航是需要自己写的，需要考虑需求和公共部分是否有联系，比如，点击导航如何显示切换页面；菜单栏收起时是否需要在 basicLayout 里传回调，告诉 children 现在的收起状态；还有哪些组件或者样式是可以共用的等等。除了前端几个成员的配合之外，还要和后端和产品的配合，有哪些需求可以更改，哪些可以通过前端自己实现，哪些需要调接口，实现方式是什么，都需要进行商讨，初步了解了对项目整体的一个把控。 </p><p>       由于需要对项目负责，所以要负责给前端伙伴解决一些问题，有别的项目介入，需要分摊时也要接手写了一半的代码，还要解决别人的 bug 和关于公共部分的使用问题，解决别人的 bug 和接手代码都是很需要耐心的事情，也很有技术含量，需要了解别人的具体业务逻辑和 bug 出现场景来推断原因，有些也不是逻辑问题，可能是生命周期和 API 不是很熟练，可以从别人的代码里学到一些技巧和吸取一些教训，是开心和暴躁的体验。接管的话代码风格不同，所以需要重构一下，按照自己的风格去拆分功能，过程是很痛苦的，结果是很有成就的。 </p><p>       还有对一个复杂业务逻辑的思考。由于工作性质，基本上都是用键盘来写字，但是有时候需要静下来仔细思考，用本子和笔来画思路流程，这是个很好的整理思路的方式。比如今年做的一个滚轮抽奖动画，有用户展示端和发起端，思路</p></li><li><p>发起端流程有：开始按钮-&gt;开始抽奖动画，3s 倒计时，按钮 disabled-&gt;动画停，停止在中奖人处，开始按钮可点击-&gt;抽奖次数结束后按钮消失</p></li><li><p>动画方面：展示框可显示七条抽奖人，动画滚动 2.5s 后最后一次滚动将中奖人放在中间，动画由快变慢最后停止</p></li><li><p>数据处理方面：抽奖人少于七人时，重复抽奖人为七人，正常情况下，每一次滚动都截取抽奖人数组的七段，到了末尾再从头截取</p></li><li><p>调接口方面：一进入展示框就查询所有的抽奖人，点击时调用开始接口，动画停止前查询本轮中奖人并查询是否是最后一次抽奖...等等       诸如此类的复杂需求可以循序渐进分类整理自己的思路。 </p><p>       以上是 2018 的一些教训和总结，如果有想到再接着补充。以下是对今年 2019 的学习展望。 </p></li><li><p>对 ES6 学习的巩固，尤其是块级作用域、函数、数据类型及其方法、迭代器、类、promise、代理反射、模块化进行学习实践，学会项目中常见的处理方法</p></li><li><p>MVVM 的原理学习，对 vdom、双向绑定、渲染机制有自己的理解，目标是做一个简单的实现</p></li><li><p>HTTP 方面，有深层次一点的了解</p></li><li><p>typescript，在学习的基础上，在项目中有稍微复杂一点的实践</p></li><li><p>拓展类：hybrid，node，数据可视化       具体的计划视情况而定进行调整。 </p><p>       末：希望 2019 还是元气满满的学习和工作，不要轻易放弃呀。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;       2018 年结束就代表毕业以及工作一年半了，不管是业务熟练程度还是技术掌握都有了自己感知得到的进步。回顾这一年的工作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;接触的浏览器平台也从 web 端，PC 软件内嵌 H5，转到了移动端，有 H5，也有 APP 内嵌 H5，还
      
    
    </summary>
    
      <category term="年度总结" scheme="github.com/MaTonna/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="个人总结" scheme="github.com/MaTonna/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>redux简易demo</title>
    <link href="github.com/MaTonna/2018/11/22/redux%E7%AE%80%E6%98%93demo/"/>
    <id>github.com/MaTonna/2018/11/22/redux简易demo/</id>
    <published>2018-11-22T06:26:47.303Z</published>
    <updated>2019-04-25T12:17:50.709Z</updated>
    
    <content type="html"><![CDATA[<h2>demo 简介</h2><p>通过组件的事件改变 store 中的 state 值，进而改变视图，同时通过调用接口来渲染数据。地址：https://github.com/MaTonna/demoForRedux</p><h2>使用的依赖</h2><ul><li>react-redux：管理 react 当中的 state，创建一个集中管理的 store</li><li>redux-thunk： redux 的中间件，使 action 返回一个函数，组件派发事件时可以做一些处理</li><li>axios：HTTP 库，创建 http 请求</li><li>immutable|redux-immutable： 用于返回新的 state，在 reducer 中用到（不允许修改传递过来的 state）</li><li>styled-components：写组件样式的库，把每个元素当作组件来写，方便统一组件样式</li></ul><h2>目录结构</h2><p><img src="/img/content/redux-content.png" alt="目录结构"></p><h2>redux flow 思路</h2><p><img src="/img/content/reduxFlow.png" alt="redux flow"></p><h3>创建 store，整合 reducer</h3><ol><li>在入口 index.js 内引入 APP.js 和用 styled-components 创建的 reset.css</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js中</span></span><br><span class="line"><span class="keyword">import</span> &#123; GlobalStyle &#125; <span class="keyword">from</span> <span class="string">'./style'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App&gt;</span><br><span class="line">    &lt;GlobalStyle /&gt;</span><br><span class="line">  &lt;<span class="regexp">/App&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ style.js</span></span><br><span class="line"><span class="regexp">import &#123; createGlobalStyle &#125; from 'styled-components';</span></span><br><span class="line"><span class="regexp">export const GlobalStyle = createGlobalStyle`reset.css的内容`</span></span><br></pre></td></tr></table></figure></p><ol start="2"><li>在 store.js 中引入 redux-thunk 作为中间件，在创建 store 时，加入 reducer 来处理 action</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, compose, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, composeEnhancers(applyMiddleware(thunk)));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>在统一的 reducer 中使用 redux-immutable 的 combineReducers 来整合各个组件的 reducer</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux-immutable'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> headerReducer &#125; <span class="keyword">from</span> <span class="string">'../common/header/store'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">  header: headerReducer</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ol start="4"><li>在 APP.js 内引入 store， 使用 react-redux 的 Provider 将 state 传入组件</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./common/header'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure></p><h3>在组件中创建自己的 reducer，并派发 action</h3><ol><li>创建组件自己的 reducer 和 actionCreator</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reducer.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; fromJS &#125; <span class="keyword">from</span> <span class="string">'immutable'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为immutable类型数据</span></span><br><span class="line"><span class="keyword">const</span> defaultState = fromJS(&#123;</span><br><span class="line">  focused: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 默认导出一个函数，接收state和action作为参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState, action) =&gt; &#123;</span><br><span class="line">    <span class="comment">//通过接收action.type，来定义不同action的处理方式，例如：</span></span><br><span class="line">    <span class="keyword">if</span>(action.type === <span class="string">'SEARCH_FOCUS'</span>) &#123;</span><br><span class="line">      <span class="comment">//改变state的值并返回一个新的state，触发了组件里的props的变化</span></span><br><span class="line">      <span class="keyword">return</span> state.set(<span class="string">'focused'</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//actionCreator.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fromJS &#125; <span class="keyword">from</span> <span class="string">'immutable'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> searchFocus = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  type: <span class="string">'SEARCH_FOCUS'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ol start="2"><li>在组件中使用 react-redux 中的 connect 连接 APP.js 的 store，connect 中传入 mapStateToProps 和 mapDispatchToProps，作用分别为映射 store 中的 state 到组件的 props 里，和派发事件的 action</li></ol><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HearderWrapper, SearchInput &#125; <span class="keyword">from</span> <span class="string">'./style'</span>;</span><br><span class="line"><span class="comment">//store的index.js中export &#123; reducer, actionCreators &#125;</span></span><br><span class="line"><span class="keyword">import</span> &#123; actionCreators &#125; <span class="keyword">from</span> <span class="string">'./store'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hearder</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; focused, handlerInputFocus, handlerInputBlur &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;HearderWrapper&gt;</span><br><span class="line">        <span class="comment">//使用connect做了一个绑定</span></span><br><span class="line">        <span class="comment">//这里的this.props.handlerInputFocus/focused就是mapDispatchToProps里的handlerInputFocus/focused</span></span><br><span class="line">        &lt;SearchInput className=&#123;focused ? <span class="string">'focus'</span> : <span class="string">'blur'</span>&#125; onFocus=&#123;handlerInputFocus&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/HearderWrapper&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const mapStateToProps = state =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    focused: state.getIn(['header', 'focused']),</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const mapDispatchToProps = dispatch =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/发生事件时派发actionCreator</span></span><br><span class="line"><span class="regexp">    handlerInputFocus() &#123;</span></span><br><span class="line"><span class="regexp">      dispatch(actionCreators.searchFocus());</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 容器组件-负责处理数据逻辑</span></span><br><span class="line"><span class="regexp">export default connect(</span></span><br><span class="line"><span class="regexp">  mapStateToProps,</span></span><br><span class="line"><span class="regexp">  mapDispatchToProps</span></span><br><span class="line"><span class="regexp">)(Hearder);</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;demo 简介&lt;/h2&gt;
&lt;p&gt;通过组件的事件改变 store 中的 state 值，进而改变视图，同时通过调用接口来渲染数据。地址：https://github.com/MaTonna/demoForRedux&lt;/p&gt;
&lt;h2&gt;使用的依赖&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;r
      
    
    </summary>
    
      <category term="前端笔记" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="redux" scheme="github.com/MaTonna/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>express+mlab登录注册</title>
    <link href="github.com/MaTonna/2018/11/02/node%E8%AF%95%E6%B0%B4%EF%BC%88%E4%B8%80%EF%BC%89express+mlab%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/"/>
    <id>github.com/MaTonna/2018/11/02/node试水（一）express+mlab登录注册/</id>
    <published>2018-11-02T09:08:47.875Z</published>
    <updated>2019-04-25T12:17:00.792Z</updated>
    
    <content type="html"><![CDATA[<h3>简介和思路</h3><ul><li>使用express作为node框架，mlab作线上数据库，postman作为调试接口工具；</li><li>注册时匹配唯一邮箱，录入用户名、密码（用bcrypt加密过）、邮箱、头像（获取gravatar公认头像），保存数据库成功后返回用户信息；</li><li>登录时匹配用户名和密码，匹配成功后返回Bearer token令牌；</li><li>访问一个接口，校验传入的authorization是否和登录时的token匹配，匹配通过则返回接口数据，否则响应未通过认证。</li></ul><h3>github</h3><p>https://github.com/MaTonna/express-manage-web</p><h3>文件目录</h3><p><img src="/img/content/1.png" alt="文件目录"></p><h3>流程演示</h3><p>注册成功后返回用户信息<img src="/img/content/2.png" alt="用户信息">注册时邮箱重复后返回错误信息<img src="/img/content/3.png" alt="错误信息">登录成功后返回token<img src="/img/content/4.png" alt="token">密码错误返回错误信息<img src="/img/content/5.png" alt="错误信息">访问一个返回用户信息的接口，token验证通过才能获取到<img src="/img/content/6.png" alt="用户信息">token验证不通过则默认会返回验证失败<img src="/img/content/7.png" alt="验证失败"></p><h3>用到的依赖和工具</h3><ul><li>工具：postman 发送请求和接收响应，用于调接口</li><li>&quot;bcrypt&quot;: &quot;^3.0.2&quot;  对注册密码进行加密</li><li>&quot;body-parser&quot;: &quot;^1.18.3&quot;  对post请求的请求体进行解析</li><li>&quot;express&quot;: &quot;^4.16.4&quot;  nodejs框架，设置中间件响应HTTP请求，定义路由执行HTTP请求动作，给HTML页面传递参数</li><li>&quot;gravatar&quot;: &quot;^1.6.0&quot;  全球公认头像</li><li>&quot;jsonwebtoken&quot;: &quot;^8.3.0&quot; 跨域认证解决方案，用于生成token令牌，服务端认定用户身份</li><li>&quot;mongoose&quot;: &quot;^5.3.8&quot;  对mongodb进行便捷操作的对象模型工具</li><li>&quot;passport&quot;: &quot;^0.4.0&quot;  用于验证登录信息，如果token通过才能访问接口</li><li>&quot;passport-jwt&quot;: &quot;^4.0.0&quot;</li></ul><h3>server.js</h3><p>功能：配置/连接数据库，配置访问API的中间件，配置/监听端口号等等。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);</span><br><span class="line"><span class="comment">// 接口api</span></span><br><span class="line"><span class="keyword">const</span> users = <span class="built_in">require</span>(<span class="string">'./routers/api/users'</span>);</span><br><span class="line"><span class="keyword">const</span> profiles = <span class="built_in">require</span>(<span class="string">'./routers/api/profiles'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用body-parser中间件</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用中间件使用users,访问/api/users时获取到users</span></span><br><span class="line">app.use(<span class="string">'/api/users'</span>, users);</span><br><span class="line">app.use(<span class="string">'/api/profiles'</span>, profiles);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接数据库</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'./config/keys'</span>).mongoURL;</span><br><span class="line">mongoose</span><br><span class="line"> .connect(</span><br><span class="line">  db,</span><br><span class="line">  &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;</span><br><span class="line"> )</span><br><span class="line"> .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'connect'</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化passport</span></span><br><span class="line"><span class="comment">// passport的配置</span></span><br><span class="line">app.use(passport.initialize());</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./config/passport'</span>)(passport);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问主页时给页面发送数据</span></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line"> res.send(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = process.env.PORT || <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'server start'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3>users.js</h3><p>功能：接口代码，配置router<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">'bcrypt'</span>);</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>);</span><br><span class="line"><span class="keyword">const</span> gravatar = <span class="built_in">require</span>(<span class="string">'gravatar'</span>);</span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">require</span>(<span class="string">'../../config/keys'</span>);</span><br><span class="line"><span class="keyword">const</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = <span class="built_in">require</span>(<span class="string">'../../models/User'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// $router POST api/users/register</span></span><br><span class="line"><span class="comment">// @desc 返回请求的json数据</span></span><br><span class="line"><span class="comment">// @access public</span></span><br><span class="line">router.post(<span class="string">'/register'</span>, (req, res) =&gt; &#123;</span><br><span class="line"> <span class="comment">// 查询一条记录</span></span><br><span class="line"> User.findOne(&#123;</span><br><span class="line">  email: req.body.email</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">   <span class="keyword">return</span> res.status(<span class="number">400</span>).json(<span class="string">'邮箱已被注册'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> avatar = gravatar.url(<span class="string">'req.body.email'</span>, &#123; <span class="attr">s</span>: <span class="string">'200'</span>, <span class="attr">r</span>: <span class="string">'pg'</span>, <span class="attr">d</span>: <span class="string">'mm'</span> &#125;);</span><br><span class="line">   <span class="keyword">const</span> newUser = <span class="keyword">new</span> User(&#123;</span><br><span class="line">    avatar,</span><br><span class="line">    name: req.body.name,</span><br><span class="line">    email: req.body.email,</span><br><span class="line">    password: req.body.password,</span><br><span class="line">    identity: req.body.identity</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 用bcrypt对密码进行加密</span></span><br><span class="line">   bcrypt.genSalt(<span class="number">10</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, salt</span>) </span>&#123;</span><br><span class="line">    bcrypt.hash(newUser.password, salt, (err, hash) =&gt; &#123;</span><br><span class="line">     <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// hash为加密后的密码</span></span><br><span class="line">     newUser.password = hash;</span><br><span class="line">     <span class="comment">// 调用存储方法</span></span><br><span class="line">     newUser</span><br><span class="line">      .save()</span><br><span class="line">      .then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">       res.json(user);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// $router POST api/users/login</span></span><br><span class="line"><span class="comment">// @desc 返回token jwt password</span></span><br><span class="line"><span class="comment">// @access public</span></span><br><span class="line">router.post(<span class="string">'/login'</span>, (req, res) =&gt; &#123;</span><br><span class="line"> <span class="keyword">const</span> email = req.body.email;</span><br><span class="line"> <span class="keyword">const</span> password = req.body.password;</span><br><span class="line"> User.findOne(&#123; email &#125;).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">   <span class="keyword">return</span> res.status(<span class="number">404</span>).json(<span class="string">'用户不存在'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 密码匹配</span></span><br><span class="line">  bcrypt.compare(password, user.password).then(<span class="function"><span class="params">isMatch</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (isMatch) &#123;</span><br><span class="line">    <span class="comment">// 规则，加密名字，过期时间，回调</span></span><br><span class="line">    <span class="keyword">const</span> rule = &#123;</span><br><span class="line">     id: user.id,</span><br><span class="line">     name: user.name,</span><br><span class="line">     avatar: user.avatar,</span><br><span class="line">     identity: user.identity</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 登录成功后返回token，相当于一个令牌，只有令牌校验成功，才可以获取想要的数据</span></span><br><span class="line">    jwt.sign(rule, keys.secretOrKey, &#123; <span class="attr">expiresIn</span>: <span class="number">3600</span> &#125;, (err, token) =&gt; &#123;</span><br><span class="line">     <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">     &#125;</span><br><span class="line">     res.json(&#123;</span><br><span class="line">      success: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 必须加Bearer</span></span><br><span class="line">      token: <span class="string">'Bearer '</span> + token</span><br><span class="line">     &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// res.json(&#123; msg: 'success' &#125;);</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res.status(<span class="number">404</span>).json(<span class="string">'密码错误'</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// $router GET api/users/current</span></span><br><span class="line"><span class="comment">// @desc 返回current user</span></span><br><span class="line"><span class="comment">// @access private</span></span><br><span class="line">router.get(<span class="string">'/current'</span>, passport.authenticate(<span class="string">'jwt'</span>, &#123; <span class="attr">session</span>: <span class="literal">false</span> &#125;), (req, res) =&gt; &#123;</span><br><span class="line"> res.json(&#123;</span><br><span class="line">  id: req.user.id,</span><br><span class="line">  name: req.user.name,</span><br><span class="line">  email: req.user.email,</span><br><span class="line">  identity: req.user.identity</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p><h3>User.js</h3><p>功能：配置mongoose的模型<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建模型和所需要的字段</span></span><br><span class="line"><span class="keyword">const</span> UserSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line"> name: &#123;</span><br><span class="line">  type: <span class="built_in">String</span>,</span><br><span class="line">  required: <span class="literal">true</span></span><br><span class="line"> &#125;,</span><br><span class="line"> email: &#123;</span><br><span class="line">  type: <span class="built_in">String</span>,</span><br><span class="line">  required: <span class="literal">true</span></span><br><span class="line"> &#125;,</span><br><span class="line"> password: &#123;</span><br><span class="line">  type: <span class="built_in">String</span>,</span><br><span class="line">  required: <span class="literal">true</span></span><br><span class="line"> &#125;,</span><br><span class="line"> avatar: &#123;</span><br><span class="line">  type: <span class="built_in">String</span></span><br><span class="line"> &#125;,</span><br><span class="line"> identity: &#123;</span><br><span class="line">  type: <span class="built_in">String</span>,</span><br><span class="line">  required: <span class="literal">true</span></span><br><span class="line"> &#125;,</span><br><span class="line"> data: &#123;</span><br><span class="line">  type: <span class="built_in">Date</span>,</span><br><span class="line">  <span class="keyword">default</span>: <span class="built_in">Date</span>.now</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = User = mongoose.model(<span class="string">'users'</span>, UserSchema);</span><br></pre></td></tr></table></figure></p><h3>passport.js</h3><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> JwtStrategy = <span class="built_in">require</span>(<span class="string">'passport-jwt'</span>).Strategy,</span><br><span class="line"> ExtractJwt = <span class="built_in">require</span>(<span class="string">'passport-jwt'</span>).ExtractJwt;</span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> User = mongoose.model(<span class="string">'users'</span>);</span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">require</span>(<span class="string">'../config/keys'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> opts = &#123;&#125;;</span><br><span class="line">opts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();</span><br><span class="line">opts.secretOrKey = keys.secretOrKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">// passport验证token</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">passport</span> =&gt;</span> &#123;</span><br><span class="line"> passport.use(</span><br><span class="line">  <span class="keyword">new</span> JwtStrategy(opts, (jwt_payload, done) =&gt; &#123;</span><br><span class="line">   User.findById(jwt_payload.id)</span><br><span class="line">    .then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (user) &#123;</span><br><span class="line">      <span class="keyword">return</span> done(<span class="literal">null</span>, user);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line"> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3>keys.js</h3><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> mongoURL: <span class="string">'mongodb://manager-web:twj123456@ds147233.mlab.com:47233/resful-api-prod'</span>,</span><br><span class="line"> secretOrKey: <span class="string">'secret'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;简介和思路&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用express作为node框架，mlab作线上数据库，postman作为调试接口工具；&lt;/li&gt;
&lt;li&gt;注册时匹配唯一邮箱，录入用户名、密码（用bcrypt加密过）、邮箱、头像（获取gravatar公认头像），保存数据库成功后
      
    
    </summary>
    
      <category term="前端笔记" scheme="github.com/MaTonna/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="node" scheme="github.com/MaTonna/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>base64 转 blob 通用方法</title>
    <link href="github.com/MaTonna/2018/10/24/base64%20%E8%BD%AC%20blob%20%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>github.com/MaTonna/2018/10/24/base64 转 blob 通用方法/</id>
    <published>2018-10-24T11:20:27.337Z</published>
    <updated>2019-04-25T12:16:24.430Z</updated>
    
    <content type="html"><![CDATA[<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dataURItoBlob(base64Data) &#123;</span><br><span class="line">    <span class="keyword">let</span> byteString;</span><br><span class="line">    <span class="keyword">if</span> (base64Data.split(<span class="string">','</span>)[<span class="number">0</span>].indexOf(<span class="string">'base64'</span>) &gt;= <span class="number">0</span>) byteString = atob(base64Data.split(<span class="string">','</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> byteString = <span class="built_in">unescape</span>(base64Data.split(<span class="string">','</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">let</span> mimeString = base64Data</span><br><span class="line">      .split(<span class="string">','</span>)[<span class="number">0</span>]</span><br><span class="line">      .split(<span class="string">':'</span>)[<span class="number">1</span>]</span><br><span class="line">      .split(<span class="string">';'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(byteString.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; byteString.length; i++) &#123;</span><br><span class="line">      ia[i] = byteString.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Blob([ia], &#123; <span class="attr">type</span>: mimeString &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;sp
      
    
    </summary>
    
      <category term="tips" scheme="github.com/MaTonna/categories/tips/"/>
    
    
  </entry>
  
  <entry>
    <title>vue监听多个data值变化</title>
    <link href="github.com/MaTonna/2018/10/24/vue%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AAdata%E5%80%BC%E5%8F%98%E5%8C%96/"/>
    <id>github.com/MaTonna/2018/10/24/vue监听多个data值变化/</id>
    <published>2018-10-24T08:41:13.231Z</published>
    <updated>2019-04-25T12:17:04.322Z</updated>
    
    <content type="html"><![CDATA[<h3>操作方法</h3><ul><li>使用 computed<a href="https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7">计算属性</a>定义一个变量，用来返回多个 data 值</li><li>使用 watch<a href="https://cn.vuejs.org/v2/api/#vm-watch">侦听属性</a>控制变量，当变量发生改变时，执行函数，并加上 deep:true 的选项参数，用于发现对象内部值的变化</li></ul><h3>代码演示</h3><p>使用场景，表单验证时，其中一个控件为空，则不允许点击提交按钮</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  allFormParam() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value1, value2, value3 &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value1, value2, value3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;，</span><br><span class="line">watch: &#123;</span><br><span class="line">  allFormParam: &#123;</span><br><span class="line">    handler(val) &#123;</span><br><span class="line">      <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val.hasOwnProperty(key) &amp;&amp; val[key] !== <span class="string">''</span>) &#123;</span><br><span class="line">          flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.formBtnDisabled = flag;</span><br><span class="line">    &#125;,</span><br><span class="line">    deep: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;操作方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用 computed&lt;a href=&quot;https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7&quot;&gt;计算属性&lt;/a&gt;定义一个变量，
      
    
    </summary>
    
      <category term="tips" scheme="github.com/MaTonna/categories/tips/"/>
    
    
      <category term="vue" scheme="github.com/MaTonna/tags/vue/"/>
    
  </entry>
  
</feed>
