<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>MaTonna&#39;s blog</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_859455_eaq7v6w8ktj.css">
</head>
<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="/" class="header-nav-link">
                首页
            </a>
            

            
            <a href="/archives" class="header-nav-link">
                归档
            </a>
            

            

            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="/" class="mobile-nav-title-link">MaTonna's Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="/" class="mobile-nav-link">首页</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="/archives" class="mobile-nav-link">归档</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="/tags" class="mobile-nav-link">标签</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/about/" class="mobile-nav-link">关于</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/04/25/处理树组件需要的数据结构/">处理树组件需要的数据结构</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-04-25</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/前端笔记/">前端笔记</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <p>基本数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const treeData = [</span><br><span class="line">      &#123; id: <span class="string">'1'</span>, parentId: <span class="string">'0'</span>, name: <span class="string">'KK总部'</span>, orderNumber: 0.0, hasChild: <span class="literal">true</span>, enabled: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; id: <span class="string">'11'</span>, parentId: <span class="string">'1'</span>, name: <span class="string">'财务'</span>, orderNumber: 0.0, hasChild: <span class="literal">true</span>, enabled: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; id: <span class="string">'12'</span>, parentId: <span class="string">'11'</span>, name: <span class="string">'财务0-1'</span>, orderNumber: 0.0, hasChild: <span class="literal">false</span>, enabled: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; id: <span class="string">'13'</span>, parentId: <span class="string">'11'</span>, name: <span class="string">'财务0-2'</span>, orderNumber: 0.0, hasChild: <span class="literal">false</span>, enabled: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; id: <span class="string">'3'</span>, parentId: <span class="string">'1'</span>, name: <span class="string">'销售部'</span>, orderNumber: 0.0, hasChild: <span class="literal">false</span>, enabled: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; id: <span class="string">'4'</span>, parentId: <span class="string">'1'</span>, name: <span class="string">'客服部'</span>, orderNumber: 0.0, hasChild: <span class="literal">false</span>, enabled: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; id: <span class="string">'5'</span>, parentId: <span class="string">'1'</span>, name: <span class="string">'行政部'</span>, orderNumber: 0.0, hasChild: <span class="literal">false</span>, enabled: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; id: <span class="string">'2'</span>, parentId: <span class="string">'0'</span>, name: <span class="string">'KK总部1'</span>, orderNumber: 0.0, hasChild: <span class="literal">true</span>, enabled: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; id: <span class="string">'7'</span>, parentId: <span class="string">'2'</span>, name: <span class="string">'财务1'</span>, orderNumber: 0.0, hasChild: <span class="literal">false</span>, enabled: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; id: <span class="string">'8'</span>, parentId: <span class="string">'2'</span>, name: <span class="string">'销售部1'</span>, orderNumber: 0.0, hasChild: <span class="literal">false</span>, enabled: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; id: <span class="string">'9'</span>, parentId: <span class="string">'2'</span>, name: <span class="string">'客服部1'</span>, orderNumber: 0.0, hasChild: <span class="literal">false</span>, enabled: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; id: <span class="string">'10'</span>, parentId: <span class="string">'2'</span>, name: <span class="string">'行政部1'</span>, orderNumber: 0.0, hasChild: <span class="literal">false</span>, enabled: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; id: <span class="string">'14'</span>, parentId: <span class="string">'0'</span>, name: <span class="string">'外部的部门'</span>, orderNumber: 0.0, hasChild: <span class="literal">false</span>, enabled: <span class="literal">true</span> &#125;,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p>处理数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 找出根节点</span><br><span class="line">const rootTreeData = treeData.filter(item =&gt; &#123;</span><br><span class="line">	<span class="built_in">return</span> item.parentId === <span class="string">'0'</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 找出根节点后循环添加children</span><br><span class="line">rootTreeData.forEach((root: any) =&gt; &#123;</span><br><span class="line">	pushChildren(root.id, root)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 处理子节点，判断是否有children，有的话就递归添加children</span><br><span class="line">const pushChildren = (id: string, root: &#123; children: any, hasChild: boolean &#125;) =&gt; &#123;</span><br><span class="line">	treeData.forEach((item: any) =&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span> (root.hasChild &amp;&amp; item.parentId === id) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!root.children) &#123;</span><br><span class="line">				root.children = [];</span><br><span class="line">			&#125;</span><br><span class="line">			root.children.push(item)</span><br><span class="line">			pushChildren(item.id, item)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终的数据结构：<br><img src="/img/content/tree-data.png" alt="数据结构"><br><img src="/img/content/tree.png" alt="最终效果"></p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/04/23/使用Babel开发Typescript/">使用Babel开发Typescript</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-04-23</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/前端笔记/">前端笔记</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev typescript</span><br><span class="line">npm install --save-dev @babel/core</span><br><span class="line">npm install --save-dev @babel/cli</span><br><span class="line">npm install --save-dev @babel/plugin-proposal-class-properties</span><br><span class="line">npm install --save-dev @babel/plugin-proposal-object-rest-spread</span><br><span class="line">npm install --save-dev @babel/preset-env</span><br><span class="line">npm install --save-dev @babel/preset-typescript</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="配置-tsconfig-json-文件"><a href="#配置-tsconfig-json-文件" class="headerlink" title="配置 tsconfig.json 文件"></a>配置 tsconfig.json 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    // Target latest version of ECMAScript.</span><br><span class="line">    &quot;target&quot;: &quot;esnext&quot;,</span><br><span class="line">    // Search under node_modules for non-relative imports.</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class="line">    // Process &amp; infer types from .js files.</span><br><span class="line">    &quot;allowJs&quot;: true,</span><br><span class="line">    // Don&apos;t emit; allow Babel to transform files.</span><br><span class="line">    &quot;noEmit&quot;: true,</span><br><span class="line">    // Enable strictest settings like strictNullChecks &amp; noImplicitAny.</span><br><span class="line">    &quot;strict&quot;: true,</span><br><span class="line">    // Disallow features that require cross-file information for emit.</span><br><span class="line">    &quot;isolatedModules&quot;: true,</span><br><span class="line">    // Import non-ES modules as default imports.</span><br><span class="line">    &quot;esModuleInterop&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;include&quot;: [</span><br><span class="line">    &quot;src&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置-babel"><a href="#配置-babel" class="headerlink" title="配置 babel"></a>配置 babel</h4><p>在根目录下创建 .babelrc 文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        &quot;@babel/preset-env&quot;,</span><br><span class="line">        &quot;@babel/preset-typescript&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;@babel/proposal-class-properties&quot;,</span><br><span class="line">        &quot;@babel/proposal-object-rest-spread&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建-src-index-ts-文件"><a href="#创建-src-index-ts-文件" class="headerlink" title="创建 src/index.ts 文件"></a>创建 src/index.ts 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export class C &#123;</span><br><span class="line">    private x = 10</span><br><span class="line">    getX = () =&gt; this.x;</span><br><span class="line">    setX = (newVal: number) =&gt; &#123; this.x = newVal; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export let x = new C();</span><br><span class="line">export let y = &#123; ...&#123; some: &quot;value&quot; &#125; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置-build-任务"><a href="#配置-build-任务" class="headerlink" title="配置 build 任务"></a>配置 build 任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build:js&quot;: &quot;babel src --out-dir lib --extensions \&quot;.ts,.tsx\&quot; --source-maps inline&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-TypeScript-开发-Ant-Design"><a href="#使用-TypeScript-开发-Ant-Design" class="headerlink" title="使用 TypeScript 开发 Ant Design"></a>使用 TypeScript 开发 Ant Design</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react react-dom @types/react @types/react-dom</span><br><span class="line">npm install --save-dev @babel/preset-react</span><br><span class="line">npm install --save antd</span><br></pre></td></tr></table></figure>
<p>安装 babel-plugin-import，可以提供按需加载功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-plugin-import</span><br></pre></td></tr></table></figure>
<p>.babelrc 文件要做相应的配置：</p>
<ul>
<li>在 presets 中增加 “@babel/preset-react”</li>
<li>plugins 中增加 [“import”, { “libraryName”: “antd”, “libraryDirectory”: “lib”}, “ant”]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        &quot;@babel/preset-env&quot;,</span><br><span class="line">        &quot;@babel/preset-react&quot;,</span><br><span class="line">        &quot;@babel/preset-typescript&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;@babel/proposal-class-properties&quot;,</span><br><span class="line">        &quot;@babel/proposal-object-rest-spread&quot;,</span><br><span class="line">        [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot;&#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发 React ，tsconfig.json 要做相应的配置，将 jsx 编译选项设为 react：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">     ...</span><br><span class="line">      &quot;jsx&quot;: &quot;react&quot; /* Specify JSX code generation: &apos;preserve&apos;, &apos;react-native&apos;, or &apos;react&apos;. */</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-webpack"><a href="#使用-webpack" class="headerlink" title="使用 webpack"></a>使用 webpack</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack webpack-cli babel-loader</span><br><span class="line">npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure>
<h4 id="创建-webpack-config-js"><a href="#创建-webpack-config-js" class="headerlink" title="创建 webpack.config.js"></a>创建 webpack.config.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    // Change to your &quot;entry-point&quot;.</span><br><span class="line">    entry: &apos;./src/index&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: &apos;app.bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &apos;style-loader&apos;,</span><br><span class="line">                    &apos;css-loader&apos;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                // Include ts, tsx, js, and jsx files.</span><br><span class="line">                test: /\.(ts|js)x?$/,</span><br><span class="line">                exclude: /node_modules/,</span><br><span class="line">                loader: &apos;babel-loader&apos;,</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [&apos;.ts&apos;, &apos;.tsx&apos;, &apos;.js&apos;, &apos;.json&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="创建-src-index-tsx"><a href="#创建-src-index-tsx" class="headerlink" title="创建 src/index.tsx"></a>创建 src/index.tsx</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import App from &quot;./App&quot;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App /&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<h4 id="创建-src-App-tsx"><a href="#创建-src-App-tsx" class="headerlink" title="创建 src/App.tsx"></a>创建 src/App.tsx</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; Button &#125; from &apos;antd&apos;;</span><br><span class="line"></span><br><span class="line">interface AppState &#123;</span><br><span class="line">    clickCount: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App extends React.Component&lt;any, AppState&gt; &#123;</span><br><span class="line"></span><br><span class="line">    constructor(props: any)&#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">        this.state = &#123;</span><br><span class="line">        clickCount: 0</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onButtonClick = () =&gt; &#123;</span><br><span class="line">        let count = this.state.clickCount + 1;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">        clickCount: count</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">                &lt;Button type=&quot;primary&quot; onClick=&#123;this.onButtonClick&#125;&gt;第&#123;this.state.clickCount&#125;次点击&lt;/Button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
<h4 id="创建-dist-index-html-文件"><a href="#创建-dist-index-html-文件" class="headerlink" title="创建 dist/index.html 文件"></a>创建 dist/index.html 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Ant Design&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>运行 webpack 命令<br>打开 dist/index.html 文件，查看效果</p>
<p>参考资料：<br><a href="https://github.com/Microsoft/TypeScript-Babel-Starter">https://github.com/Microsoft/TypeScript-Babel-Starter</a><br><a href="https://zhuanlan.zhihu.com/p/59023070">https://zhuanlan.zhihu.com/p/59023070</a></p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/03/20/H5的rem适配方案/">H5的rem适配方案</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-03-20</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/tips/">tips</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(doc, win) &#123;</span><br><span class="line">  var docEl = doc.documentElement,</span><br><span class="line">    resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> window ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,</span><br><span class="line">    //750 为设计稿宽度  适配rem</span><br><span class="line">    recalc = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      var clientWidth = docEl.clientWidth;</span><br><span class="line">      <span class="keyword">if</span> (!clientWidth) <span class="built_in">return</span>;</span><br><span class="line">      clientWidth = clientWidth &lt;= 1080 ? clientWidth : 1080;</span><br><span class="line">      docEl.style.fontSize = (clientWidth / 750) * 100 + <span class="string">'px'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">if</span> (!doc.addEventListener) <span class="built_in">return</span>;</span><br><span class="line">  win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);</span><br><span class="line">  doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);</span><br><span class="line">&#125;)(document, window);</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;1rem = body 的 px 倍数，按照在 css 中就以设计稿/100 的 rem 来写。<br>&#160; &#160; &#160; &#160;按照爱疯 6 的 375 宽度来计算，根节点的 font-size 设置为 50px。</p>
<p>&#160; &#160; &#160; &#160;另外，在公共的 css 中设置 body，确保在 PC 上查看页面也不会变形：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-width: 320px;</span><br><span class="line">max-width: 640px;</span><br></pre></td></tr></table></figure>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/03/01/封装调用接口的函数，返回接口的返回值/">封装调用接口的函数，返回接口的返回值</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-03-01</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/tips/">tips</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <ul>
<li>封装公共函数的 js：publicFunc.js</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const getData = () =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    axios.get(url,param)</span><br><span class="line">      .<span class="keyword">then</span>((req) =&gt; &#123;</span><br><span class="line">        const data = req;  //接口返回值做处理</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch((err) =&gt; &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> default &#123;getData&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">showMyData = async () =&gt; &#123;</span><br><span class="line">   <span class="built_in">let</span> data = await getData();</span><br><span class="line">   this.setState(&#123;</span><br><span class="line">     data</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/02/22/解决IOS上new Image()的onload事件失效/">解决IOS上new Image()的onload事件失效</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-02-22</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/tips/">tips</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a>业务场景：</h3><p>H5 的客服中，根据用户输入付款金额以及选择付款方式，生成一张带有付款二维码、付款金额、若干提示语的图片。</p>
<h3 id="封装绘制方法的基本思路："><a href="#封装绘制方法的基本思路：" class="headerlink" title="封装绘制方法的基本思路："></a>封装绘制方法的基本思路：</h3><ol>
<li>调用接口获得二维码图片地址</li>
<li>new Image()并 onload 后在 canvas 上绘制图片生成信息</li>
<li>完成绘制后执行回调，返回 canvas</li>
<li>回调中调用 canvas.toDataURL(‘image/png’)将 canvas 转成 base64</li>
</ol>
<h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><p>在 IOS 中无法绘制图片，经过排查发现是因为 onload 事件失效，所以使用 fetch()获取图片，在 then()中做后续操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">// 调用绘制二维码</span><br><span class="line">this.drawPayQRCode(&#123;</span><br><span class="line">  qrImgUrl: <span class="string">'二维码地址'</span>,</span><br><span class="line">  logoImgUrl: <span class="string">'支付通道的 logo'</span>,</span><br><span class="line">  sum: <span class="string">'金额'</span>,</span><br><span class="line">  userLoginName: <span class="string">'用户名'</span>,</span><br><span class="line">  branchName: <span class="string">'彩店名'</span>,</span><br><span class="line">  payproductName: <span class="string">'支付通道名'</span>,</span><br><span class="line">  tipList: [<span class="string">'文案 1'</span>,<span class="string">'文案 2'</span>,<span class="string">'文案 3'</span>],</span><br><span class="line">  callback: <span class="keyword">function</span>(canvas) &#123;</span><br><span class="line">    const imgUrl = canvas.toDataURL(<span class="string">'image/png'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 定义绘制二维码的方法</span><br><span class="line">drawPayQRCode(options) &#123;</span><br><span class="line">  const canvas = document.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">  const canvasWidth = 280;</span><br><span class="line">  const canvasHeight = 270;</span><br><span class="line">  canvas.width = canvasWidth;</span><br><span class="line">  canvas.height = canvasHeight;</span><br><span class="line">  const context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">  // 定义背景色</span><br><span class="line">  context.fillStyle = <span class="string">'#fff'</span>;</span><br><span class="line">  context.fillRect(0, 0, canvasWidth, canvasHeight);</span><br><span class="line"></span><br><span class="line">  //定义二维码和支付通道 logo 的位置</span><br><span class="line">  const qrL = (280 - 150) / 2;</span><br><span class="line">  const qrR = 26;</span><br><span class="line">  const qrWH = 150;</span><br><span class="line">  const logoL = (280 - 24) / 2;</span><br><span class="line">  const logoR = 89;</span><br><span class="line">  const logoWH = 24;</span><br><span class="line"></span><br><span class="line">    const qrImg = new Image();</span><br><span class="line">  // 判断机型为 ios</span><br><span class="line">  <span class="keyword">if</span> (CONFIG.browser.ios) &#123;</span><br><span class="line">     // 加载二维码图片</span><br><span class="line">     this.fetchImage(options.qrImgUrl, <span class="keyword">function</span>(myBlob) &#123;</span><br><span class="line">     const objectURL = URL.createObjectURL(myBlob); // 将 Blob 生成 URL</span><br><span class="line">     qrImg.src = objectURL;</span><br><span class="line"></span><br><span class="line">     // 延迟检查图片是否加载完成，可以改为轮询形式，complete 成功后关掉定时器</span><br><span class="line">     setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (qrImg.complete) &#123;</span><br><span class="line">        // 绘制二维码图片</span><br><span class="line">        context.drawImage(qrImg, qrL, qrR, qrWH, qrWH);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">        const logoImg = new Image();</span><br><span class="line">        // 加载支付通道 logo，原理同上</span><br><span class="line">        this.fetchImage(options.logoImgUrl, <span class="keyword">function</span>(myBlob) &#123;</span><br><span class="line">        const objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">        logoImg.src = objectURL;</span><br><span class="line">        setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">           <span class="keyword">if</span> (logoImg.complete) &#123;</span><br><span class="line">           context.drawImage(logoImg, logoL, logoR, logoWH, logoWH);</span><br><span class="line">           // 完成绘制后，执行回调</span><br><span class="line">           options.callback(canvas);</span><br><span class="line">         &#125;</span><br><span class="line">         &#125;, 60);</span><br><span class="line">      &#125;);</span><br><span class="line">      &#125;, 60);</span><br><span class="line">   &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     //图片跨域访问</span><br><span class="line">     qrImg.setAttribute(<span class="string">'crossOrigin'</span>, <span class="string">'Anonymous'</span>);</span><br><span class="line"></span><br><span class="line">     qrImg.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">     context.drawImage(qrImg, qrL, qrR, qrWH, qrWH);</span><br><span class="line">     //下载支付通道 logo</span><br><span class="line">     const logoImg = new Image();</span><br><span class="line">     logoImg.setAttribute(<span class="string">'crossOrigin'</span>, <span class="string">'Anonymous'</span>);</span><br><span class="line"></span><br><span class="line">     logoImg.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        context.drawImage(logoImg, logoL, logoR, logoWH, logoWH);</span><br><span class="line">        // 完成绘制后，回调</span><br><span class="line">        options.callback(canvas);</span><br><span class="line">      &#125;;</span><br><span class="line">     logoImg.src = options.logoImgUrl;</span><br><span class="line">   &#125;;</span><br><span class="line">     qrImg.src = options.qrImgUrl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  context.font = <span class="string">'12px Helvetica Neue,Tahoma,Arial,PingFangSC-Regular,Hiragino Sans GB,Microsoft Yahei,sans-serif'</span>;</span><br><span class="line"></span><br><span class="line">  // 金额样式</span><br><span class="line">  context.fillStyle = <span class="string">'#f00'</span>;</span><br><span class="line">  context.textAlign = <span class="string">'center'</span>;</span><br><span class="line">  context.fillText(`￥<span class="variable">$&#123;options.sum&#125;</span>`, 140, 26 + 150 + 10);</span><br><span class="line">  context.fillText(`仅限<span class="variable">$&#123;options.userLoginName&#125;</span> <span class="variable">$&#123;options.branchName&#125;</span>使用`, 140, 26 + 150 + 25);</span><br><span class="line"></span><br><span class="line">  // 提示语样式</span><br><span class="line">  context.fillStyle = <span class="string">'#000'</span>;</span><br><span class="line">  context.textAlign = <span class="string">'left'</span>;</span><br><span class="line">  const tipList = options.tipList;</span><br><span class="line"></span><br><span class="line">  //如果是微信付款就添加提交数据</span><br><span class="line">  <span class="keyword">if</span> (options.payproductName === <span class="string">'WECHAT'</span>) &#123;</span><br><span class="line">     tipList[0] = <span class="string">'请打开微信 APP 扫一扫'</span>;</span><br><span class="line">     tipList.splice(2, 0, <span class="string">'请勿在扫码页面从相册选取二维码进行识别'</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  const len = tipList.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; len; i++) &#123;</span><br><span class="line">     context.fillText(i + 1 + <span class="string">'.'</span> + tipList[i] + (i === len - 1 ? <span class="string">'。'</span> : <span class="string">'；'</span>), 16, 220 + 16 \* i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">fetchImage(imgUrl, cb) &#123;</span><br><span class="line">  fetch(imgUrl)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(res) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.ok) &#123;</span><br><span class="line">    <span class="built_in">return</span> res.blob();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span>(myBlob) &#123;</span><br><span class="line">    cb(myBlob);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;由于fetch有些兼容性的问题，所以会考虑到用xhr来实验一下，用xhr来获取图片的Blob：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;img id=<span class="string">"myImg"</span> src=<span class="string">""</span> /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">function</span> loadImage(url, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      callback = <span class="keyword">function</span>(url) &#123;</span><br><span class="line">        console.log(url);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.responseType = <span class="string">'blob'</span>;</span><br><span class="line">    xhr.onload = <span class="keyword">function</span>(req) &#123;</span><br><span class="line">      console.log(xhr.response)</span><br><span class="line">      const resToUrl = window.URL.createObjectURL(xhr.response);</span><br><span class="line">      console.log(resToUrl)</span><br><span class="line">      callback(resToUrl);</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //使用方法</span><br><span class="line">  var imgUrl = <span class="string">'http://qimg.hxnews.com/2019/0203/1549199908936.jpg'</span>;</span><br><span class="line">  loadImage(imgUrl, <span class="keyword">function</span>(url) &#123;</span><br><span class="line">    document.getElementById(<span class="string">'myImg'</span>).setAttribute(<span class="string">'src'</span>, url);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/02/20/小程序-组件/">小程序-组件篇</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-02-20</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/前端笔记/">前端笔记</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>&#160; &#160; &#160; &#160;与页面类似，一个自定义组件也由 json、wxml、wxss、js 四个文件组成。编写自定义组件需要在 json 文件中声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;component&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;在页面中使用自定义组件之前，要在页面的 json 文件中进行引用声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;usingComponents&quot;: &#123;</span><br><span class="line">        // 自定义标签名只能包含小写字母，中划线和下划线</span><br><span class="line">        &quot;component-tag-name&quot;: &quot;page/to/custom/component&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;然后就可以使用自定义组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;component-tag-name inner-text=&quot;Some text&quot;&gt;&lt;/component-tag-name&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>
<h3 id="组件模板和样式"><a href="#组件模板和样式" class="headerlink" title="组件模板和样式"></a>组件模板和样式</h3><p>&#160; &#160; &#160; &#160;可以向组件传递<slot>节点，用于承载需要组件引用的子节点。需要使用多个 slot 时需要在组件的 js 中声明，用 name 区分：</slot></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//组件 js</span><br><span class="line">Component(&#123;</span><br><span class="line">   options: &#123;</span><br><span class="line">       multipleSlots: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//组件 wxml</span><br><span class="line">&lt;view class=&quot;wrapper&quot;&gt;</span><br><span class="line"> &lt;slot name=&quot;before&quot;&gt;&lt;/slot&gt;</span><br><span class="line"> &lt;view&gt;这里是组件的内部细节&lt;/view&gt;</span><br><span class="line"> &lt;slot name=&quot;after&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">//页面 wxml</span><br><span class="line">&lt;view&gt;</span><br><span class="line"> // 可以使用数据绑定向子组件的属性传递动态数据</span><br><span class="line"> &lt;component-tag-name prop-a=&quot;&#123;&#123;dataFieldA&#125;&#125;&quot; prop-b=&quot;&#123;&#123;dataFieldB&#125;&#125;&quot;&gt;</span><br><span class="line">   &lt;view slot=&quot;before&quot;&gt;这里是插入到组件 slot name=&quot;before&quot;中的内容&lt;/view&gt;</span><br><span class="line">   &lt;view slot=&quot;after&quot;&gt;这里是插入到组件 slot name=&quot;after&quot;中的内容&lt;/view&gt;</span><br><span class="line"> &lt;/component-tag-name&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;组件对应的 wxss 文件的样式只对组件 wxml 内的节点生效，在组件内不能使用 id、属性、标签、后代选择器，子元素选择器&gt;只能用于 view 组件和其子节点。可以使用:host 指定所在节点的默认样式。<br>&#160; &#160; &#160; &#160;在自定义组件激活 addGlobalClass 选项可以让自定义组件能被 app.wxss 或页面的 wxss 中的所有样式影响。<br>&#160; &#160; &#160; &#160;在 Component 中可以用 externalClasses 定义若干个外部样式类，样式类是写在页面中的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 页面 wxml</span><br><span class="line">&lt;custom-component my-class=&quot;red-text&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 组件 wxml    </span><br><span class="line">&lt;custom-component class=&quot;my-class&quot;&gt;</span><br><span class="line">  这段文本的颜色由组件外的 class 决定</span><br><span class="line">&lt;/custom-component&gt;</span><br><span class="line"></span><br><span class="line">// 组件 js</span><br><span class="line">Component(&#123;</span><br><span class="line"> externalClasses: [&apos;my-class&apos;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Component-构造器"><a href="#Component-构造器" class="headerlink" title="Component 构造器"></a>Component 构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line"> // 用于组件间的代码共享，可以使用 Behavior()构造器定义，每个 behavior 包含一组属性、数据、声明周期和方法，被组件引用时，这些东西会被合并到组件中去</span><br><span class="line"> behaviors: [],</span><br><span class="line"></span><br><span class="line"> properties: &#123;</span><br><span class="line">   // 如果用 Component 构造页面，在 properties 中可以接收到页面参数</span><br><span class="line">   myProperty: &#123; // 属性名</span><br><span class="line">     type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）</span><br><span class="line"></span><br><span class="line">     value: &apos;&apos;, // 属性初始值（可选），如果未指定则会根据类型选择一个</span><br><span class="line"></span><br><span class="line">     observer(newVal, oldVal, changedPath) &#123;</span><br><span class="line">       // 属性被改变时执行的函数（可选），也可以写成在 methods 段中定义的方法名字符串, 如：&apos;\_propertyChange&apos;</span><br><span class="line">       // 通常 newVal 就是新设置的数据， oldVal 是旧数据</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">   myProperty2: String // 简化的定义方式</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> data: &#123;&#125;, // 私有数据，可用于模板渲染</span><br><span class="line"></span><br><span class="line"> lifetimes: &#123;</span><br><span class="line">   // 生命周期函数，可以为函数，或一个在 methods 段中定义的方法名</span><br><span class="line">   attached() &#123; &#125;, // 在组件实例进入页面节点树时</span><br><span class="line"></span><br><span class="line">   moved() &#123; &#125;, // 在组件实例被移动到节点树另一个位置时执行</span><br><span class="line"></span><br><span class="line">   detached() &#123; &#125;, // 在组件实例从页面节点树移除时执行</span><br><span class="line"></span><br><span class="line">   // 还有 created、ready、error 生命周期</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> pageLifetimes: &#123;</span><br><span class="line">   // 组件所在页面的生命周期函数</span><br><span class="line"></span><br><span class="line">   show() &#123; &#125;, // 页面被展示时执行</span><br><span class="line"></span><br><span class="line">   hide() &#123; &#125;, // 页面被隐藏时执行</span><br><span class="line"></span><br><span class="line">   resize() &#123; &#125;, //页面尺寸变化时执行</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> methods: &#123;</span><br><span class="line">   onMyButtonTap() &#123;</span><br><span class="line">     this.setData(&#123;</span><br><span class="line">       // 更新属性和数据的方法与更新页面数据的方法类似</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   // 内部方法建议以下划线开头</span><br><span class="line">   _myPrivateMethod() &#123;</span><br><span class="line">     // 这里将 data.A[0].B 设为 &apos;myPrivateData&apos;</span><br><span class="line">     this.setData(&#123;</span><br><span class="line">       &apos;A[0].B&apos;: &apos;myPrivateData&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   _propertyChange(newVal, oldVal) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;组件中包含一些通用属性和方法，可以通过 this 访问：<br><img src="/img/content/component-this.png" alt="组件的通用属性和方法"></p>
<h3 id="组件间通信、事件与关系"><a href="#组件间通信、事件与关系" class="headerlink" title="组件间通信、事件与关系"></a>组件间通信、事件与关系</h3><h4 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h4><p>&#160; &#160; &#160; &#160;父 -&gt; 子：wxml 数据绑定通过设置属性传递数据，或通过 this.selectComponent 方法获取子组件实例对象<br>&#160; &#160; &#160; &#160;子 -&gt; 父：通过事件传递数据</p>
<h4 id="监听-触发事件"><a href="#监听-触发事件" class="headerlink" title="监听/触发事件"></a>监听/触发事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 监听事件</span><br><span class="line">// 父组件 wxml</span><br><span class="line">&lt;component-tag-name bind:myevent=&quot;onMyEvent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 父组件 js</span><br><span class="line">Page(&#123;</span><br><span class="line"> onMyEvent(e) &#123;</span><br><span class="line">   e.detail // 自定义组件触发事件时提供的 detail 对象</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 触发事件</span><br><span class="line">// 子组件 wxml</span><br><span class="line">&lt;button bind:tap=&quot;onTap&quot;&gt;点击这个按钮将触发“myevent”事件&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">// 子组件 js</span><br><span class="line">Component(&#123;</span><br><span class="line"> properties: &#123;&#125;,</span><br><span class="line"></span><br><span class="line"> methods: &#123;</span><br><span class="line">   onTap() &#123;</span><br><span class="line">     const myEventDetail = &#123;&#125; // detail 对象，提供给事件监听函数</span><br><span class="line"></span><br><span class="line">     // 触发事件的选项</span><br><span class="line">     const myEventOption = &#123;</span><br><span class="line">         bubbles: Boolean,    // 表示事件是否冒泡，默认为 false</span><br><span class="line">         composed: Boolean,    // 表示事件是否可以穿越组件边界，默认为 false</span><br><span class="line">         capturePhase: Boolean,    //表示事件是否有捕获阶段，默认为 false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     this.triggerEvent(&apos;myevent&apos;, myEventDetail, myEventOption)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="组件间关系"><a href="#组件间关系" class="headerlink" title="组件间关系"></a>组件间关系</h4><p>&#160; &#160; &#160; &#160;如果两个自定义组件有嵌套关系，相互间的通信比较复杂，可以加入 relations 定义段。需要在两个组件定义中都加入 relations 定义，否则不会生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 组件 wxml</span><br><span class="line">&lt;custom-ul&gt;</span><br><span class="line"> &lt;custom-li&gt;item 1&lt;/custom-li&gt;</span><br><span class="line"> &lt;custom-li&gt;item 2&lt;/custom-li&gt;</span><br><span class="line">&lt;/custom-ul&gt;</span><br><span class="line"></span><br><span class="line">// 外层组件 js</span><br><span class="line">Component(&#123;</span><br><span class="line"> relations: &#123;</span><br><span class="line">   &apos;./custom-li&apos;: &#123;</span><br><span class="line">     type: &apos;child&apos;, // 关联的目标节点应为子节点</span><br><span class="line"></span><br><span class="line">     linked(target) &#123;</span><br><span class="line">       // 每次有 custom-li 被插入时执行，target 是该节点实例对象，触发在该节点 attached 生命周期之后</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">     linkChanged(target) &#123;</span><br><span class="line">       // 每次有 custom-li 被移动后执行，target 是该节点实例对象，触发在该节点 moved 生命周期之后</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">     unlinked(target) &#123;</span><br><span class="line">       // 每次有 custom-li 被移除时执行，target 是该节点实例对象，触发在该节点 detached 生命周期之后</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> methods: &#123;</span><br><span class="line">   _getAllLi() &#123;</span><br><span class="line">     // 使用 getRelationNodes 可以获得 nodes 数组，包含所有已关联的 custom-li，且是有序的</span><br><span class="line">     const nodes = this.getRelationNodes(&apos;path/to/custom-li&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> ready() &#123;</span><br><span class="line">   this._getAllLi()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;内层组件写法类似，type 为 parent，linked / linkChanged / unlinked 代表被插入/移动/移除时执行。<br>&#160; &#160; &#160; &#160;如果外层组件想要关联两个内层组件，并且如果两个组件都有一个 behavior：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 组件 wxml</span><br><span class="line">&lt;custom-form&gt;</span><br><span class="line"> &lt;view&gt;</span><br><span class="line">   input</span><br><span class="line">   &lt;custom-input&gt;&lt;/custom-input&gt;</span><br><span class="line"> &lt;/view&gt;</span><br><span class="line"> &lt;custom-submit&gt;submit&lt;/custom-submit&gt;</span><br><span class="line">&lt;/custom-form&gt;</span><br><span class="line"></span><br><span class="line">// 外层组件 js</span><br><span class="line">const customFormControls = require(&apos;./custom-form-controls&apos;)</span><br><span class="line">Component(&#123;</span><br><span class="line"> relations: &#123;</span><br><span class="line">   customFormControls: &#123;</span><br><span class="line">     type: &apos;descendant&apos;, // 关联的目标节点应为子孙节点</span><br><span class="line">     target: customFormControls</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 内层组件 js</span><br><span class="line">const customFormControls = require(&apos;./custom-form-controls&apos;)</span><br><span class="line">Component(&#123;</span><br><span class="line"> behaviors: [customFormControls],</span><br><span class="line"></span><br><span class="line"> relations: &#123;</span><br><span class="line">   &apos;./custom-form&apos;: &#123;</span><br><span class="line">     type: &apos;ancestor&apos;, // 关联的目标节点应为祖先节点</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="抽象节点"><a href="#抽象节点" class="headerlink" title="抽象节点"></a>抽象节点</h3><p>&#160; &#160; &#160; &#160;当自定义组件模板中的节点由调用者决定时，就可以把节点声明为抽象节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 一个选框组组件，可以放置单选框或者复选框</span><br><span class="line">// 组件 wxml</span><br><span class="line">&lt;view wx:for=&quot;&#123;&#123;labels&#125;&#125;&quot;&gt;</span><br><span class="line"> &lt;label&gt;</span><br><span class="line">   &lt;selectable disabled=&quot;&#123;&#123;false&#125;&#125;&quot;&gt;&lt;/selectable&gt;</span><br><span class="line">  &#123;&#123;item&#125;&#125;</span><br><span class="line"> &lt;/label&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">// 组件 json</span><br><span class="line">&#123;</span><br><span class="line"> &quot;componentGenerics&quot;: &#123;</span><br><span class="line">   &quot;selectable&quot;: true</span><br><span class="line">   // 可以指定一个默认组件</span><br><span class="line">   //&quot;selectable&quot;: &#123;</span><br><span class="line">   // &quot;default&quot;: &quot;path/to/default/component&quot;</span><br><span class="line">   //&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用组件的 wxml</span><br><span class="line">&lt;selectable-group generic:selectable=&quot;custom-radio&quot; /&gt;</span><br><span class="line">&lt;selectable-group generic:selectable=&quot;custom-checkbox&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// 调用组件的 json，有可能调用的组件都需要包含在 json 的 usingComponent 中</span><br><span class="line">&#123;</span><br><span class="line"> &quot;usingComponents&quot;: &#123;</span><br><span class="line">   &quot;custom-radio&quot;: &quot;path/to/custom/radio&quot;,</span><br><span class="line">   &quot;custom-checkbox&quot;: &quot;path/to/custom/checkbox&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/02/18/小程序-基础/">小程序-框架基础篇</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-02-18</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/前端笔记/">前端笔记</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h3 id="vscode-插件："><a href="#vscode-插件：" class="headerlink" title="vscode 插件："></a>vscode 插件：</h3><p>&#160; &#160; &#160; &#160;minapp-标签属性智能补全</p>
<h3 id="框架："><a href="#框架：" class="headerlink" title="框架："></a>框架：</h3><h4 id="1-小程序的启动"><a href="#1-小程序的启动" class="headerlink" title="1.小程序的启动"></a>1.小程序的启动</h4><p>&#160; &#160; &#160; &#160;微信在打开小程序之前，把整个代码包下载到本地<br>&#160; &#160; &#160; &#160;读取 app.json 的 pages 字段知道所有的页面路径，然后通过 pages 字段的第一个值的路径装载并渲染首页<br>&#160; &#160; &#160; &#160;启动后，在 app.js 定义的 App 实例的 onLaunch 回调被执行</p>
<h4 id="2-注册程序：App"><a href="#2-注册程序：App" class="headerlink" title="2.注册程序：App()"></a>2.注册程序：App()</h4><p>&#160; &#160; &#160; &#160;app.js：是小程序入口，其中调用 App()函数来注册一个小程序，参数为小程序的声明周期回调等等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  onLaunch(options) &#123;</span><br><span class="line">    // 初始化完成时调用（全局只触发一次）</span><br><span class="line">    // 参数里可以拿到当前路径、场景代号等，可以通过wx.getLaunchOptionsSync获取</span><br><span class="line">  &#125;,</span><br><span class="line">	</span><br><span class="line">  onShow(options) &#123;</span><br><span class="line">    // 在启动、从后台进入前台时调用（后台是指用户点击右上角的关闭或者按了设备的home键离开微信，再次打开时进入前台）</span><br><span class="line">    // 小程序运行机制：https://developers.weixin.qq.com/miniprogram/dev/framework/operating-mechanism.html</span><br><span class="line">    // 用wx.onAppShow可以绑定监听</span><br><span class="line">    // 参数同onLaunch</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onHide() &#123;</span><br><span class="line">    // 从前台进入后台时触发</span><br><span class="line">    // 用wx.onAppHide可以绑定监听</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onError(msg) &#123;</span><br><span class="line">    // 脚本错误、api调用失败时触发</span><br><span class="line">    // 用wx.onError可以绑定监听</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onPageNotFound() &#123;</span><br><span class="line">    // 要打开的页面不存在时触发</span><br><span class="line">    // 参数带有页面信息</span><br><span class="line">    // 用wx.onPageNotFound可以绑定监听</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 除此之外可以添加任意方法或数据</span><br><span class="line">  // 可以用this可以访问</span><br><span class="line">  globalData: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;全局的 getApp()函数可以用来获取到小程序 App 实例。</p>
<h4 id="3-注册页面：Page"><a href="#3-注册页面：Page" class="headerlink" title="3.注册页面：Page()"></a>3.注册页面：Page()</h4><p>&#160; &#160; &#160; &#160;Page(Object)用来注册一个页面，参数可以指定页面的初试数据，生命周期回调，事件处理函数等。<br>&#160; &#160; &#160; &#160;高级用法是用 Component 创建页面，就可以使用自定义组件的特性，比如用 behaviors 进行代码复用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    // 页面初始数据，页面加载时data会以JSON字符串的形式由逻辑层传至渲染层</span><br><span class="line">    // data中的数据必须是字符串、数字、布尔值、对象、数组</span><br><span class="line">    // 渲染层可以通过WXML进行数据绑定</span><br><span class="line">    text: &apos;This is page data.&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onLoad(query) &#123;</span><br><span class="line">    // 监听页面加载</span><br><span class="line">    // 参数可以获取打开当前页面路径中的参数</span><br><span class="line">    // 例：当前url为../logs/logs?abc=1，参数query即为&#123;&quot;abc&quot;: 1&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onShow() &#123;</span><br><span class="line">    // 监听页面显示/切入前台事件</span><br><span class="line">    console.log(this.route) // this中还有当前页面的路径</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onReady() &#123;</span><br><span class="line">    // 监听页面初次渲染完成，一个页面只会调用一次，表示页面可以和视图层进行交互</span><br><span class="line">    // 如果要对界面内容进行设置，要在onReady之后的生命周期进行</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onHide() &#123;</span><br><span class="line">    // 监听页面隐藏/切入后台事件</span><br><span class="line">    // 如navigateTo或tab切换到其他页面</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onUnload() &#123;</span><br><span class="line">    // 监听页面卸载</span><br><span class="line">    // 如redireactTo或navigateBack到其他页面</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onPullDownRefresh() &#123;</span><br><span class="line">    // 监听用户下拉刷新动作</span><br><span class="line">    // 需要在app.json的window选项或页面配置中开启enablePullDownRefresh</span><br><span class="line">    // 可以通过wx.startPullDownRefresh触发</span><br><span class="line">    // 处理完数据刷新后，wx.stopPullDownRefresh可以停止下拉刷新</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onReachBottom() &#123;</span><br><span class="line">    // 监听上拉触底事件</span><br><span class="line">    // 在app.json的window选项或页面配置中设置触发距离onReachBottomDistance</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onShareAppMessage(Object) &#123;</span><br><span class="line">    // 用户点击右上角转发，或点击转发按钮&lt;button open-type=&quot;share&quot; /&gt;</span><br><span class="line">    // 参数 Object包含from: button/menu，target:button/undefined，webViewUrl:&lt;web-view&gt;的url</span><br><span class="line">    return &#123;</span><br><span class="line">        title: &apos;&apos;, // 默认为当前小程序名称</span><br><span class="line">        path: &apos;&apos;, // 转发路径，当前页面的完整路径</span><br><span class="line">        imageUrl: &apos;&apos; // 显示图片路径，支持png/jpg，默认使用默认截图，长宽比为5:4</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onPageScroll(Object) &#123;</span><br><span class="line">    // 页面滚动触发事件</span><br><span class="line">    // 参数中的scrollTop可以获取页面在垂直方向已滚动的距离px</span><br><span class="line">    // 不要定义空方法，减少不必要的事件派发对渲染层-逻辑层通信的影响</span><br><span class="line">    // 避免过于频繁的执行setState引起通信操作，传递大量数据会影响通信耗时</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onResize(res) &#123;</span><br><span class="line">    // 页面尺寸改变触发事件</span><br><span class="line">    // 在手机上/ipad启用屏幕旋转支持可以触发</span><br><span class="line">    // 读取页面的显示尺寸，可以用SelectorQuery.selectViewport()</span><br><span class="line">    res.size.windowWidth // 新的显示区域宽度</span><br><span class="line">    res.size.windowHeight // 新的显示区域高度</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onTabItemTap(item) &#123;</span><br><span class="line">    // 当前是tab页时，点击tab时触发</span><br><span class="line">    console.log(item.index) // 被点击tabItem的序号</span><br><span class="line">    console.log(item.pagePath) // 被点击tabItem的页面路径</span><br><span class="line">    console.log(item.text) // 被点击tabItem的按钮文字</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 其他函数和数据</span><br><span class="line">  // 定义组件事件处理函数，在渲染层的组件中加入事件绑定，就会进入到事件处理函数</span><br><span class="line">  // &lt;view bindtap=&quot;viewTap&quot;&gt;click me&lt;/view&gt;</span><br><span class="line">  viewTap() &#123;</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      text: &apos;Set some data for updating view.&apos;</span><br><span class="line">      // 支持修改数组中的某一项或对象的某个属性，并且可以不需要在this.data中预先定义，不要设为undefined</span><br><span class="line">    &#125;, function () &#123;</span><br><span class="line">      // this is setData callback</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  customData: &#123;</span><br><span class="line">    hi: &apos;MINA&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="4-页面路由"><a href="#4-页面路由" class="headerlink" title="4.页面路由"></a>4.页面路由</h4><p>&#160; &#160; &#160; &#160;所有页面的路由都由框架以栈的形式进行管理。getCurrentPages()用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。<br>&#160; &#160; &#160; &#160;App.onLaunch 的时候不要调用 getCurrentPages()，这时候 page 还没有生成。<br>&#160; &#160; &#160; &#160;路由方式和对应的声明周期：<br><img src="/img/content/wx-router.png" alt="路由方式和对应的声明周期"><br>Tab 切换对应的生命周期，A、B 为 tabbar 页面，C 是从 A 页面打开的，D 是从 C 页面打开的<br><img src="/img/content/wx-router-tab.png" alt="Tab切换对应的生命周期"></p>
<h4 id="5-WXML-和-vue-的-template-用法区别"><a href="#5-WXML-和-vue-的-template-用法区别" class="headerlink" title="5.WXML 和 vue 的 template 用法区别"></a>5.WXML 和 vue 的 template 用法区别</h4><ul>
<li><p>列表渲染<br>&#160; &#160; &#160; &#160;不需要写 item,index in array，默认当前项变量名为 item，当前下标变量名为 index，可以使用 wx:for-item、wx:for-index 重新制定当前元素和下标的变量名。<br>&#160; &#160; &#160; &#160;如果是动态渲染的列表，需要用 wx:key 来制定列表中项目的唯一标识符，值可以是唯一的字符串/数字，或保留关键字*this（代表在 for 循环中的 item 本身）。当数据改变触发渲染层重新渲染时，会矫正带有 key 的组件，确保他们被重新排序而不是重新创建，以确保使组件保持自身的状态，提高列表渲染时的效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt;&lt;/view&gt;</span><br></pre></td></tr></table></figure>
<p>注：wx:for 的值为字符串时，会将字符串解析成字符串数组，花括号之间有空格，会被解析成字符串。</p>
</li>
<li><p>事件使用方式<br>&#160; &#160; &#160; &#160;冒泡事件：key 以 bind（不会阻止冒泡事件向上冒泡）、catch（阻止冒泡事件向上冒泡）开头，非原生组件中，bind 和 catch 可以紧跟一个冒号，含义不变，如 bind-tap<br>&#160; &#160; &#160; &#160;非冒泡事件：key 以 capture-bind、capture-catch（中断捕获阶段和取消冒泡阶段）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;tapName&quot;&gt;点击&lt;/view&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&#160; &#160; &#160; &#160;支持使用 WXS 函数绑定时间，接收 event 和 ownerInstance 两个参数，ownerInstance 和 event.instance 一样是一个 ComponentDescriptor 对象，可以设置组件的样式和 class。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;wxs module=&quot;wxs&quot; src=&quot;./test.wxs&quot;&gt;&lt;/wxs&gt;</span><br><span class="line">&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;&#123;&#123;wxs.tapName&#125;&#125;&quot;&gt;点击&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">// test.wxs</span><br><span class="line">function tapName(event, ownerInstance) &#123;</span><br><span class="line"> console.log(&apos;tap wechat&apos;, JSON.stringify(event))</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line"> tapName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>文件引用方式</li>
</ul>
<p>&#160; &#160; &#160; &#160;import：在文件中使用目标文件定义的 template，有作用域的概念，不会 import 目标文件 import 的 template。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- A.wxml --&gt;</span><br><span class="line">&lt;template name=&quot;A&quot;&gt;</span><br><span class="line">  &lt;text&gt;A template&lt;/text&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- B.wxml --&gt;</span><br><span class="line">&lt;import src=&quot;a.wxml&quot; /&gt;</span><br><span class="line">&lt;template is=&quot;A&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;include：将目标文件除了template标签和wxs标签之外的整个代码引入，相当于拷贝到 include 位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.wxml --&gt;</span><br><span class="line">&lt;include src=&quot;header.wxml&quot; /&gt;</span><br><span class="line">&lt;view&gt;body&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- header.wxml --&gt;</span><br><span class="line">&lt;view&gt;header&lt;/view&gt;</span><br></pre></td></tr></table></figure></p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/02/12/浏览器缓存机制/">浏览器缓存机制</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-02-12</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/前端面试之道/">前端面试之道</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <p>&#160; &#160; &#160; &#160;缓存可以简单高效的优化性能，可以显著减少网络传输带来的损耗。浏览器缓存可以帮我们在数据请求中的网络请求和浏览器响应这两步优化性能，直接使用缓存而不发起请求，或者发起请求但是后端存储的数据和前端一致，就没有必要将数据返回回来，就减少了响应数据。</p>
<h3 id="1-缓存位置"><a href="#1-缓存位置" class="headerlink" title="1. 缓存位置"></a>1. 缓存位置</h3><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p>&#160; &#160; &#160; &#160;它是浏览器背后的独立线程，一般用来实现缓存功能。传输协议必须是 https，因为涉及到请求拦截，必须用 https 协议来保障安全。<br>&#160; &#160; &#160; &#160;实现缓存功能步骤：</p>
<ol>
<li>注册 Service Worker</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">'sw.js'</span>)</span><br><span class="line">    .<span class="keyword">then</span>(<span class="keyword">function</span>(registration) &#123;</span><br><span class="line">      console.log(<span class="string">'service worker 注册成功'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="keyword">function</span>(err) &#123;</span><br><span class="line">      console.log(<span class="string">'servcie worker 注册失败'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>监听到 install 事件，缓存需要的文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// sw.js</span><br><span class="line">// 监听 `install` 事件，回调中缓存所需文件</span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, e =&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'my-cache'</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(cache) &#123;</span><br><span class="line">      <span class="built_in">return</span> cache.addAll([<span class="string">'./index.html'</span>, <span class="string">'./index.js'</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>下次用户访问就通过拦截请求查询是否存在缓存，存在则直接读取文件，否则就去请求数据</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 拦截所有请求事件</span><br><span class="line">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, e =&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).<span class="keyword">then</span>(<span class="keyword">function</span>(response) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="built_in">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(<span class="string">'fetch source'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;在开发者工具中的 Application 可以看到 Service Worker 已经启动，Cache 中也可以看到我们缓存的文件。</p>
<h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>&#160; &#160; &#160; &#160;Memory Cache 是内存中的缓存，读取速度比磁盘快，但是缓存持续时间短，随着进程的释放而释放，一旦关闭 tab 页，内存中的缓存就会被释放。<br>&#160; &#160; &#160; &#160;但是不能让数据都存在内存中，计算机内存比硬盘容量小，大文件一般不存储在内存中，内存如果使用率高，文件会优先存储进硬盘。</p>
<h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p>&#160; &#160; &#160; &#160;Disk Cache 是存储在硬盘中的缓存，虽然速度较慢，但是比 Memory Cache 胜在容量和存储时效性上。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。即使跨站点，相同地址的资源一旦被硬盘缓存下来就不会重新请求数据。</p>
<h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><p>&#160; &#160; &#160; &#160;Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时才会使用，缓存时间短暂，只在 session 中，一旦 session 结束就会被释放。</p>
<h3 id="2-缓存策略"><a href="#2-缓存策略" class="headerlink" title="2. 缓存策略"></a>2. 缓存策略</h3><p>&#160; &#160; &#160; &#160;浏览器缓存策略分为强缓存和协商缓存两种，都是通过设置 HTTP Header 来实现的。</p>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>&#160; &#160; &#160; &#160;强缓存表示在缓存期间不需要请求，state code 为 200。</p>
<ol>
<li>设置 Expires</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 22 Oct 2018 08:41:00 GMT</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;表示会在特定的时间后过期，需要再次请求。但是 Expires 受限于本地时间，修改了本地时间可能会造成缓存失败。</p>
<ol start="2">
<li>设置 Cache-control</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-control: max-age=30</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;表示资源会在 30s 后过期，需要再次请求，优先级高于 Expires，可以在请求头或者响应头中设置，可以组合使用多种指令。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。<br><img src="/img/content/cache-control.png" alt="常见指令作用"></p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>&#160; &#160; &#160; &#160;协商缓存表示如果缓存过期了，需要发起请求验证资源是否有更新。当浏览器发起请求验证资源时，如果资源没有改变则返回 304，并且更新浏览器缓存有效期。</p>
<ol>
<li>设置 Last-Modified<br>&#160; &#160; &#160; &#160;Last-Modified 表示本地文件最后修改地址，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话则讲新的资源文件发送回来，否则返回 304。<br>&#160; &#160; &#160; &#160;但是如果本地打开了缓存文件，会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源。Last-Modified 以秒计时，如果在不可感知的时间内修改完文件，服务端则认为资源命中，不会返回正确的资源。</li>
<li>设置 ETag<br>&#160; &#160; &#160; &#160;ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问 ETag 是否改变，有变动就发送新资源回来，并且优先级高于 Last-Modified。</li>
</ol>
<p>&#160; &#160; &#160; &#160;<strong>如果没有设置任何缓存策略，浏览器会采用一个启发式的算法，通常取响应头中的 Date 减去 Last-Modified 值的 10%作为缓存时间。</strong><br>&#160; &#160; &#160; &#160;<strong>缓存的优先级：Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified</strong><br><img src="/img/content/cache-flow.png" alt="浏览器缓存机制流程图"></p>
<h3 id="实际场景应用缓存策略"><a href="#实际场景应用缓存策略" class="headerlink" title="实际场景应用缓存策略"></a>实际场景应用缓存策略</h3><h4 id="频繁变动的资源"><a href="#频繁变动的资源" class="headerlink" title="频繁变动的资源"></a>频繁变动的资源</h4><p>&#160; &#160; &#160; &#160;频繁变动的资源首先使用 Cache-Control: no-cache 使浏览器每次都请求服务器，再配合 ETag 或者 Last-Modified 来验证资源是否有效，可以减少响应数据的大小。</p>
<h4 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h4><p>&#160; &#160; &#160; &#160;可以用打包工具给文件名进行哈希处理，代码修改后才会生成新的文件名。然后就可以给代码文件设置一年的有效期 Cache-Control: max-age=3153600，这样就只有当 HTML 文件引入的文件名发生变化才会去下载最新的代码文件，否则就一直使用缓存。</p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/01/25/浏览器基础知识点及常考面试题/">浏览器基础知识点及常考面试题</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-01-25</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/前端面试之道/">前端面试之道</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h3 id="1-事件机制"><a href="#1-事件机制" class="headerlink" title="1. 事件机制"></a>1. 事件机制</h3><p>&#160; &#160; &#160; &#160;<strong>面试题：事件的触发过程是怎么样的？什么是事件代理？</strong></p>
<ul>
<li>事件触发<br>事件触发的三个阶段：</li>
</ul>
<ol>
<li>从 window 往事件触发处传播，遇到注册的捕获事件会触发</li>
<li>传播到事件触发处时触发注册的时间</li>
<li>从事件触发处往 window 传播，遇到注册的冒泡事件会触发</li>
</ol>
<p>&#160; &#160; &#160; &#160;<strong>注：</strong>如果给 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。<br>&#160; &#160; &#160; &#160;通常使用 addEventListener 注册事件，第三个参数是布尔值或者对象，布尔值默认为 false 表示捕获，对象可以使用{captrue:布尔值（true 冒泡，false 捕获）, once:布尔值（true 表示回调只会调用一次，调用后移除）, passive:布尔值（true 表示永远不会调用 preventDefault）}<br>&#160; &#160; &#160; &#160;stopPropagation 可以阻止事件的冒泡和捕获，stopImmediatePropagation 也可以阻止事件，还能阻止该事件目标执行别的注册事件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">  console.log(<span class="string">'冒泡'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">// node被点击后，以下的事件不会执行了</span><br><span class="line">node.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">  console.log(<span class="string">'捕获'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>事件代理（事件委托）<br>&#160; &#160; &#160; &#160;只指定一个事件处理程序，就可以管理某一类型的所有事件。原理是利用事件的冒泡机制，从最深的节点开始逐渐向上传播事件，冒泡到指定的父节点代为执行事件。<br>&#160; &#160; &#160; &#160;例如， ul 上面的所有 li 都需要相同的 click 事件，没有用事件代理就会用 for 循环的方式，遍历所有的 li 来添加事件，这样的问题是添加到页面上的事件处理函数数量与页面整体运行性能挂钩，因为需要不断地与 dom 进行交互，引起的浏览器重绘和重排就越多，会延长整个页面的交互就绪时间，再者每个函数都是一个对象，对象就会占用内存，内存占用率越大性能就会越差。使用事件委托与 dom 操作就只需要操作一次，可以提高性能和节约内存空间。</li>
</ul>
<h3 id="2-跨域"><a href="#2-跨域" class="headerlink" title="2. 跨域"></a>2. 跨域</h3><p>&#160; &#160; &#160; &#160;<strong>面试题：什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求吗？</strong></p>
<p>&#160; &#160; &#160; &#160;浏览器处于安全考虑有同源策略。协议、域名、端口有一个不同就是跨域，请求会失败。主要是用来防止 CSRF（Cross-site request forgery）攻击，简单来说是利用用户的登录状态发起恶意请求。<br>&#160; &#160; &#160; &#160;session 的理解：例如有一张会员卡，可以享受一些会员权利，会员卡是客户的唯一标识，会员卡卡号就是保存在 cookie 的 sessionId，会员卡权利和个人信息就是服务端的 session 对象。http 请求是无状态的，但是每次 http 请求都会将本域名下的所有 cookie 作为 http 请求头的一部分发送给服务端，所以服务端就根据请求中的 cookie 中的 sessionId 去 session 对象中查找用户信息了。<br>&#160; &#160; &#160; &#160;CSRF 攻击的主要目的是让用户在不知情的情况下攻击自己已登录的一个系统，例如在网站中点击一个图片就会构造一个去论坛发帖的请求，去你的论坛发帖，由于你的浏览器状态是登录的，所以 session 登录的 cookie 信息都会和正常的请求一样。<br>&#160; &#160; &#160; &#160;防御可以通过 referer、token 或者验证码检测用户提交，不要在链接中暴露用户信息，使用 post 操作，严格设置 cookie 的域。<br>&#160; &#160; &#160; &#160;请求跨域后，请求发出去了，但是浏览器拦截了响应。通过表单可以发起跨域请求，因为表单不会获取新的内容，但是 ajax 可以获取响应，所以 ajax 不可以发起跨域请求。所以说明跨域限制并不能完全阻止 CSRF，因为请求已经发出去了。<br>&#160; &#160; &#160; &#160;<strong>如何解决跨域的问题？</strong></p>
<h4 id="同源策略限制下接口请求的方式"><a href="#同源策略限制下接口请求的方式" class="headerlink" title="同源策略限制下接口请求的方式"></a>同源策略限制下接口请求的方式</h4><ol>
<li>JSONP<br>&#160; &#160; &#160; &#160;在 HTML 标签中，script、img 这样获取资源的标签是没有跨域限制的，所以利用这一点，我们可以通过 script 标签指向一个需要访问的地址并提供一个回调函数来接收数据，不过 script 加载资源是 GET 请求，如果要使用 POST 请求，可以用空 iframe+form。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//callback是前后端约定的方法名，后端返回一个直接执行的方法给前端，由于是用script标签发起的请求，所以返回方法后立即执行，并且把要返回的数据放在方法的参数里</span><br><span class="line">&lt;script src=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> jsonp(data) &#123;</span><br><span class="line">      console.log(data)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;做一个简单的封装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* JSONP请求工具</span><br><span class="line">* @param url 请求的地址</span><br><span class="line">* @param data 请求的参数</span><br><span class="line">* @returns &#123;Promise&lt;any&gt;&#125;</span><br><span class="line">*/</span><br><span class="line">const request = (&#123;url, data&#125;) =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 处理传参成xx=yy&amp;aa=bb的形式</span><br><span class="line">    const handleData = (data) =&gt; &#123;</span><br><span class="line">      const keys = Object.keys(data)</span><br><span class="line">      const keysLen = keys.length</span><br><span class="line">      <span class="built_in">return</span> keys.reduce((pre, cur, index) =&gt; &#123;</span><br><span class="line">        const value = data[cur]</span><br><span class="line">        const flag = index !== keysLen - 1 ? <span class="string">'&amp;'</span> : <span class="string">''</span></span><br><span class="line">        <span class="built_in">return</span> `<span class="variable">$&#123;pre&#125;</span><span class="variable">$&#123;cur&#125;</span>=<span class="variable">$&#123;value&#125;</span><span class="variable">$&#123;flag&#125;</span>`</span><br><span class="line">      &#125;, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    // 动态创建script标签</span><br><span class="line">    const script = document.createElement(<span class="string">'script'</span>)</span><br><span class="line">    // 接口返回的数据获取</span><br><span class="line">    window.jsonpCb = (res) =&gt; &#123;</span><br><span class="line">      document.body.removeChild(script)</span><br><span class="line">      delete window.jsonpCb</span><br><span class="line">      resolve(res)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = `<span class="variable">$&#123;url&#125;</span>?<span class="variable">$&#123;handleData(data)&#125;</span>&amp;cb=jsonpCb`</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 使用方式</span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">'http://localhost:9871/api/jsonp'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    // 传参</span><br><span class="line">    msg: <span class="string">'helloJsonp'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="keyword">then</span>(res =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>CORS<br>&#160; &#160; &#160; &#160;CORS 是一个 W3C 标准，全称是“跨域资源共享”(cross-origin resource sharing)。只要服务器实现了 CORS 接口，就可以跨域通信，都是浏览器自动完成。<br>&#160; &#160; &#160; &#160;浏览器将 CORS 请求分为两类：简单请求和非简单请求。<br>&#160; &#160; &#160; &#160;同时满足以下两大条件，就属于简单请求：</li>
</ol>
<ul>
<li>请求方法是以下三种方法之一： HEAD GET POST</li>
<li>http 的头信息不超出以下几种字段：Accept Accept-Language Content-Language Last-Event-ID Content-Type(只限于 application/x-www-form-urlencoded、mutipart/form-data、text/plain)<br>&#160; &#160; &#160; &#160;不同时满足以上两个条件就属于非简单请求。</li>
</ul>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>&#160; &#160; &#160; &#160;浏览器发现跨域的 AJAX 请求是简单请求，就自动在头信息之中加一个 Origin 字段，用来说明请求源（协议+域名+端口），服务器根据这个值决定是否同意这次请求。<br>&#160; &#160; &#160; &#160;如果 Origin 指定的源不在许可范围内，服务器会返回一个正常的 HTTP 回应，浏览器发现回应的头没有包含 Access-Control-Allow-Origin 字段就知道出错了，从而抛出错误。</p>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>&#160; &#160; &#160; &#160;非简单请求是对服务器有特殊要求的请求，比如请求方法是 PUT/DELETE，或者 Content-Type 字段类型是 application/json。<br>&#160; &#160; &#160; &#160;非简单请求的 CORS 请求，会在正式通信前增加一次 HTTP 查询请求，称为“预检”请求。浏览器先询问服务器，当前域名是否在服务器的许可名单中，以及可以使用哪些 HTTP 动词和头信息字段，只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则报错。<br>&#160; &#160; &#160; &#160;一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。</p>
<ol start="3">
<li>代理<br>&#160; &#160; &#160; &#160;使用 Nginx 配置来把请求转发到真正的后端域名上。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="comment"># 监听9099端口</span></span><br><span class="line">    listen 9099;</span><br><span class="line">    <span class="comment"># 域名是localhost</span></span><br><span class="line">    server_name localhost;</span><br><span class="line">    <span class="comment">#凡是localhost:9099/api，都转发到真正的服务端地址http://localhost:9871</span></span><br><span class="line">    location ^~ /api &#123;</span><br><span class="line">        proxy_pass http://localhost:9871;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;如果后端接口是公共 API，调用时就不能去配 Nginx，CORS 才是通用的做法。</p>
<h4 id="同源策略限制下-Dom-查询的方式"><a href="#同源策略限制下-Dom-查询的方式" class="headerlink" title="同源策略限制下 Dom 查询的方式"></a>同源策略限制下 Dom 查询的方式</h4><ol>
<li>postMessage()<br>&#160; &#160; &#160; &#160;它是 H5 的一个接口，用来实现不同窗口不同页面的跨域通讯。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 发送方</span><br><span class="line">window.addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</span><br><span class="line">  // 这里一定要对来源做校验</span><br><span class="line">  <span class="keyword">if</span> (e.origin === <span class="string">'http://crossdomain.com:9099'</span>) &#123;</span><br><span class="line">    // 来自http://crossdomain.com:9099的结果回复</span><br><span class="line">    console.log(e.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 向http://crossdomain.com:9099发消息</span><br><span class="line"><span class="function"><span class="title">postMessage</span></span> () &#123;</span><br><span class="line">  const iframe = window.frames[<span class="string">'crossDomainIframe'</span>]</span><br><span class="line">  iframe.postMessage(<span class="string">'我是[http://localhost:9099], 麻烦你查一下你那边有没有id为app的Dom'</span>, <span class="string">'http://crossdomain.com:9099'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//接收方</span><br><span class="line">window.addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</span><br><span class="line">  // 这里一定要对来源做校验</span><br><span class="line">  <span class="keyword">if</span> (e.origin === <span class="string">'http://localhost:9099'</span>) &#123;</span><br><span class="line">    // http://localhost:9099发来的信息</span><br><span class="line">    console.log(e.data)</span><br><span class="line">    // e.source可以是回信的对象，其实就是http://localhost:9099窗口对象(window)的引用</span><br><span class="line">    // e.origin可以作为targetOrigin</span><br><span class="line">    e.source.postMessage(`我是[http://crossdomain.com:9099]，我知道了兄弟，这就是你想知道的结果：<span class="variable">$&#123;document.getElementById('app') ? '有id为app的Dom' : '没有id为app的Dom'&#125;</span>`, e.origin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>document.domain<br>&#160; &#160; &#160; &#160;这种方式只适合主域名相同，但子域名不同的 iframe 跨域。<br>&#160; &#160; &#160; &#160;比如主域名是<a href="http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain">http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain</a> = crossdomain.com 就可以访问各自的 window 对象了。</li>
</ol>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2019/01/23/JS进阶知识点及常考面试题/">JS进阶知识点及常考面试题</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2019-01-23</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/前端面试之道/">前端面试之道</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h3 id="1-call、apply-和-bind"><a href="#1-call、apply-和-bind" class="headerlink" title="1.call、apply 和 bind"></a>1.call、apply 和 bind</h3><p>&#160; &#160; &#160; &#160;<strong>面试题：call、apply 及 bind 函数内部实现是怎么样的？</strong></p>
<ul>
<li>定义：调用一个对象的一个方法，用另一个对象代替当前对象</li>
<li>使用：B.call(A, args1, args2)，B.apply(A, arguments)，<strong>A 对象应用 B 对象的方法</strong></li>
</ul>
<p>&#160; &#160; &#160; &#160;实现 call 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new TypeError(&apos;Error&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || window; // 可选参数，不传默认为window</span><br><span class="line">  context.fn = this; //创建fn，此时的this是需要调用的函数，本例中是add()</span><br><span class="line">  const args = [...arguments].slice(1); //剥离参数</span><br><span class="line">  const result = context.fn(...args); //调用函数</span><br><span class="line">  delete context.fn; //将对象上的函数删除</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">function add(a,b)&#123;</span><br><span class="line">  return a+b;</span><br><span class="line">&#125;</span><br><span class="line">function sub(a,b)&#123;</span><br><span class="line">  return a-b;</span><br><span class="line">&#125;</span><br><span class="line">var a1 = add.myCall(sub,4,2); //6，sub调用add的方法</span><br></pre></td></tr></table></figure>
<ul>
<li>bind()是 ES5 中的方法，<strong>bind 后函数不会立即执行，只是返回一个改变了上下文的函数副本，call 和 apply 是直接执行函数</strong>，ie6~ie8 不支持该方法<br>&#160; &#160; &#160; &#160;实现 bind 方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function (context) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new TypeError(&apos;Error&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  const _this = this;</span><br><span class="line">  const args = [...arguments].slice(1); // argument是类数组，先转成数组再去掉context</span><br><span class="line">  // 返回一个函数</span><br><span class="line">  return function F() &#123;</span><br><span class="line">    // 判断是否是通过new调用函数的，不会被任何方式改变this</span><br><span class="line">    if (this instanceof F) &#123;</span><br><span class="line">      return new _this(...args, ...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    // 因为bind可以实现f.bind(obj, 1)(2)这样的代码，所以需要将参数拼接起来</span><br><span class="line">    return _this.apply(context, args.concat(...arguments)); // 直接调用函数</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-new"><a href="#2-new" class="headerlink" title="2.new"></a>2.new</h3><p>&#160; &#160; &#160; &#160;<strong>面试题：new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别?</strong></p>
<p>&#160; &#160; &#160; &#160;通过 new 来调用构造函数时，函数体内会发生：</p>
<ol>
<li>创建一个空对象，将它的引用赋给 this，并继承函数的原型</li>
<li>通过 this 将属性和方法添加至这个对象</li>
<li>最后返回 this 指向的新对象<br>&#160; &#160; &#160; &#160;自己实现一个 new</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function create() &#123;</span><br><span class="line">  let obj = &#123;&#125;;</span><br><span class="line">  let Con = [...arguments].shift(); // 获取构造函数，例子里是t()函数</span><br><span class="line">  obj.__proto__ = Con.prototype; // 设置空对象的原型，例子里是t()函数的prototype</span><br><span class="line">  let result = Con.apply(obj, arguments); // 绑定this，执行构造函数</span><br><span class="line">  return result instanceof Object ? result : obj; //确保返回值是对象</span><br><span class="line">&#125;</span><br><span class="line">function t() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">let a = create(t);</span><br><span class="line">a; // 打印出1</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;字面量优势：</p>
<ol>
<li>代码量更少容易阅读</li>
<li>可以强调对象是一个简单的可变的散列表，不必一定派生自某个类</li>
<li>对象字面量可以在解析时被优化，不需要“作用域解析”，因为存在你已经创建了一个同名的构造函数 Object()的可能，当调用 Object()的时候，解析器需要顺着作用域链从当前作用域开始查找，找到全局 Object()构造函数为止</li>
<li>Object()可以接收参数，通过这个参数可以把对象实例的创建过程委托给另一个内置构造函数，并返回另一个对象实例，往往不是我们想要的结果</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 字符串对象</span><br><span class="line">var o = new Object(&quot;I am a string&quot;);</span><br><span class="line">console.log(o.constructor === String); // true</span><br><span class="line">// 普通对象没有substring()方法，但字符串对象有</span><br><span class="line">// 最终得到的对象是不同的构造函数生成的</span><br><span class="line">console.log(typeof o.substring); // &quot;function&quot;</span><br></pre></td></tr></table></figure>
<h3 id="3-instanceof"><a href="#3-instanceof" class="headerlink" title="3.instanceof"></a>3.instanceof</h3><p>&#160; &#160; &#160; &#160;<strong>面试题：instanceof 的原理是什么？</strong></p>
<p>&#160; &#160; &#160; &#160;instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  let prototype = right.prototype;  // 获取类型的原型</span><br><span class="line">  left = left.__proto__; // 获得对象的原型</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (left === null || left === undefined)</span><br><span class="line">      return false; // 原型链最终为null，所以搜索到对象原型为null为止</span><br><span class="line">    if (prototype === left)</span><br><span class="line">      return true;</span><br><span class="line">    left = left.__proto__; // 向原型链上一层查找</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function a() &#123;&#125;</span><br><span class="line">myInstanceof(a,Function); // true</span><br><span class="line">let b = [1,2,3]</span><br><span class="line">myInstanceof(b,Array); // true</span><br></pre></td></tr></table></figure>
<h3 id="3-数字精度问题"><a href="#3-数字精度问题" class="headerlink" title="3.数字精度问题"></a>3.数字精度问题</h3><p>&#160; &#160; &#160; &#160;<strong>面试题：为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</strong></p>
<p>&#160; &#160; &#160; &#160; 0.1 在二进制中是无限循环的一些数字，不只是 0.1，JS 采用的 IEEE 754 双精度版本（64 位）的浮点数标准会裁减掉数字，0.1 就会变成 0.100000000000000002，同样的 0.2 在二进制中也是无限循环的，所以相加不是 0.3。<br>&#160; &#160; &#160; &#160; 为什么 console.log(0.1)是正确的？因为在输入内容的时候二进制转换为了十进制，然后再转为字符串，这个转换的过程中取了近似值。<br>&#160; &#160; &#160; &#160;做计算时可以调用如下的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">floatAdd: function(arg1, arg2) &#123;</span><br><span class="line">  var r1, r2, m;</span><br><span class="line">  try &#123;</span><br><span class="line">    r1 = (&apos;&apos; + arg1).split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    r1 = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    r2 = (&apos;&apos; + arg2).split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    r2 = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  m = Math.pow(10, Math.max(r1, r2));</span><br><span class="line">  return (arg1 * m + arg2 * m) / m;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">floatSub: function(arg1, arg2) &#123;</span><br><span class="line">  var r1, r2, m, n;</span><br><span class="line">  try &#123;</span><br><span class="line">    r1 = (&apos;&apos; + arg1).split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    r1 = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    r2 = (&apos;&apos; + arg2).split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    r2 = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  m = Math.pow(10, Math.max(r1, r2));</span><br><span class="line">  //动态控制精度长度</span><br><span class="line">  n = r1 &gt;= r2 ? r1 : r2;</span><br><span class="line">  return ((arg1 * m - arg2 * m) / m).toFixed(n);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//浮点数乘法运算</span><br><span class="line">floatMul: function(arg1, arg2) &#123;</span><br><span class="line">  var m = 0,</span><br><span class="line">    s1 = &apos;&apos; + arg1,</span><br><span class="line">    s2 = &apos;&apos; + arg2;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    m += s1.split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;&#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    m += s2.split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;&#125;</span><br><span class="line">  return (</span><br><span class="line">    Number(s1.replace(&apos;.&apos;, &apos;&apos;)) *</span><br><span class="line">    Number(s2.replace(&apos;.&apos;, &apos;&apos;)) /</span><br><span class="line">    Math.pow(10, m)</span><br><span class="line">  );</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//浮点数除法运算</span><br><span class="line">floatDiv: function(arg1, arg2) &#123;</span><br><span class="line">  var t1 = 0,</span><br><span class="line">    t2 = 0,</span><br><span class="line">    r1,</span><br><span class="line">    r2;</span><br><span class="line">  try &#123;</span><br><span class="line">    t1 = (&apos;&apos; + arg1).split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;&#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    t2 = (&apos;&apos; + arg2).split(&apos;.&apos;)[1].length;</span><br><span class="line">  &#125; catch (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  r1 = Number((&apos;&apos; + arg1).replace(&apos;.&apos;, &apos;&apos;));</span><br><span class="line">  r2 = Number((&apos;&apos; + arg2).replace(&apos;.&apos;, &apos;&apos;));</span><br><span class="line">  return r1 / r2 * Math.pow(10, t2 - t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                
            </div>
        </article>
    
</div>
<div class="paginator">
    
        
        
        <a class="next" href="/page/2/">
            下一页
            <i class="iconfont icon-next"></i>
        </a>
        
    
</div>

    </div>
</div>
<footer class="footer-social">
    

    

    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
            2019
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/MaTonna">MaTonna</a>
        </p>
    </div>
</footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    

</script>
</html>
