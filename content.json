{"pages":[],"posts":[{"title":"express+mlab登录注册","text":"简介和思路 使用express作为node框架，mlab作线上数据库，postman作为调试接口工具； 注册时匹配唯一邮箱，录入用户名、密码（用bcrypt加密过）、邮箱、头像（获取gravatar公认头像），保存数据库成功后返回用户信息； 登录时匹配用户名和密码，匹配成功后返回Bearer token令牌； 访问一个接口，校验传入的authorization是否和登录时的token匹配，匹配通过则返回接口数据，否则响应未通过认证。 githubhttps://github.com/MaTonna/express-manage-web 文件目录 流程演示注册成功后返回用户信息注册时邮箱重复后返回错误信息登录成功后返回token密码错误返回错误信息访问一个返回用户信息的接口，token验证通过才能获取到token验证不通过则默认会返回验证失败 用到的依赖和工具 工具：postman 发送请求和接收响应，用于调接口 “bcrypt”: “^3.0.2” 对注册密码进行加密 “body-parser”: “^1.18.3” 对post请求的请求体进行解析 “express”: “^4.16.4” nodejs框架，设置中间件响应HTTP请求，定义路由执行HTTP请求动作，给HTML页面传递参数 “gravatar”: “^1.6.0” 全球公认头像 “jsonwebtoken”: “^8.3.0” 跨域认证解决方案，用于生成token令牌，服务端认定用户身份 “mongoose”: “^5.3.8” 对mongodb进行便捷操作的对象模型工具 “passport”: “^0.4.0” 用于验证登录信息，如果token通过才能访问接口 “passport-jwt”: “^4.0.0” server.js功能：配置/连接数据库，配置访问API的中间件，配置/监听端口号等等。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const express = require('express');const mongoose = require('mongoose');const bodyParser = require('body-parser');const passport = require('passport');// 接口apiconst users = require('./routers/api/users');const profiles = require('./routers/api/profiles');const app = express();// 使用body-parser中间件app.use(bodyParser.urlencoded({ extended: false }));app.use(bodyParser.json());// 使用中间件使用users,访问/api/users时获取到usersapp.use('/api/users', users);app.use('/api/profiles', profiles);// 链接数据库const db = require('./config/keys').mongoURL;mongoose .connect( db, { useNewUrlParser: true } ) .then(() =&gt; { console.log('connect'); }) .catch(err =&gt; { console.log(err); });// 初始化passport// passport的配置app.use(passport.initialize());require('./config/passport')(passport);// 访问主页时给页面发送数据app.get('/', (req, res) =&gt; { res.send('hello world');});const port = process.env.PORT || 5000;app.listen(port, () =&gt; { console.log('server start');}); users.js功能：接口代码，配置router123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105const express = require('express');const router = express.Router();const bcrypt = require('bcrypt');const jwt = require('jsonwebtoken');const gravatar = require('gravatar');const keys = require('../../config/keys');const passport = require('passport');const User = require('../../models/User');// $router POST api/users/register// @desc 返回请求的json数据// @access publicrouter.post('/register', (req, res) =&gt; { // 查询一条记录 User.findOne({ email: req.body.email }).then(user =&gt; { if (user) { return res.status(400).json('邮箱已被注册'); } else { var avatar = gravatar.url('req.body.email', { s: '200', r: 'pg', d: 'mm' }); const newUser = new User({ avatar, name: req.body.name, email: req.body.email, password: req.body.password, identity: req.body.identity }); // 用bcrypt对密码进行加密 bcrypt.genSalt(10, function(err, salt) { bcrypt.hash(newUser.password, salt, (err, hash) =&gt; { if (err) { throw err; } // hash为加密后的密码 newUser.password = hash; // 调用存储方法 newUser .save() .then(user =&gt; { res.json(user); }) .catch(err =&gt; { console.log(err); }); }); }); } });});// $router POST api/users/login// @desc 返回token jwt password// @access publicrouter.post('/login', (req, res) =&gt; { const email = req.body.email; const password = req.body.password; User.findOne({ email }).then(user =&gt; { if (!user) { return res.status(404).json('用户不存在'); } // 密码匹配 bcrypt.compare(password, user.password).then(isMatch =&gt; { if (isMatch) { // 规则，加密名字，过期时间，回调 const rule = { id: user.id, name: user.name, avatar: user.avatar, identity: user.identity }; // 登录成功后返回token，相当于一个令牌，只有令牌校验成功，才可以获取想要的数据 jwt.sign(rule, keys.secretOrKey, { expiresIn: 3600 }, (err, token) =&gt; { if (err) { throw err; } res.json({ success: true, // 必须加Bearer token: 'Bearer ' + token }); }); // res.json({ msg: 'success' }); } else { return res.status(404).json('密码错误'); } }); });});// $router GET api/users/current// @desc 返回current user// @access privaterouter.get('/current', passport.authenticate('jwt', { session: false }), (req, res) =&gt; { res.json({ id: req.user.id, name: req.user.name, email: req.user.email, identity: req.user.identity });});module.exports = router; User.js功能：配置mongoose的模型12345678910111213141516171819202122232425262728293031const mongoose = require('mongoose');const Schema = mongoose.Schema;// 创建模型和所需要的字段const UserSchema = new Schema({ name: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, avatar: { type: String }, identity: { type: String, required: true }, data: { type: Date, default: Date.now }});module.exports = User = mongoose.model('users', UserSchema); passport.js12345678910111213141516171819202122232425262728const JwtStrategy = require('passport-jwt').Strategy, ExtractJwt = require('passport-jwt').ExtractJwt;const mongoose = require('mongoose');const User = mongoose.model('users');const keys = require('../config/keys');const opts = {};opts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();opts.secretOrKey = keys.secretOrKey;// passport验证tokenmodule.exports = passport =&gt; { passport.use( new JwtStrategy(opts, (jwt_payload, done) =&gt; { User.findById(jwt_payload.id) .then(user =&gt; { if (user) { return done(null, user); } else { return done(null, false); } }) .catch(err =&gt; { console.log(err); }); }) );}; keys.js1234module.exports = { mongoURL: 'mongodb://manager-web:twj123456@ds147233.mlab.com:47233/resful-api-prod', secretOrKey: 'secret'};","link":"/2018/11/02/node试水（一）express+mlab登录注册/"},{"title":"base64 转 blob 通用方法","text":"1234567891011121314dataURItoBlob(base64Data) { let byteString; if (base64Data.split(',')[0].indexOf('base64') &gt;= 0) byteString = atob(base64Data.split(',')[1]); else byteString = unescape(base64Data.split(',')[1]); let mimeString = base64Data .split(',')[0] .split(':')[1] .split(';')[0]; let ia = new Uint8Array(byteString.length); for (let i = 0; i &lt; byteString.length; i++) { ia[i] = byteString.charCodeAt(i); } return new Blob([ia], { type: mimeString });}","link":"/2018/10/24/base64 转 blob 通用方法/"},{"title":"vue监听多个data值变化","text":"操作方法 使用 computed计算属性定义一个变量，用来返回多个 data 值 使用 watch侦听属性控制变量，当变量发生改变时，执行函数，并加上 deep:true 的选项参数，用于发现对象内部值的变化 代码演示使用场景，表单验证时，其中一个控件为空，则不允许点击提交按钮 12345678910111213141516171819202122computed: { allFormParam() { const { value1, value2, value3 } = this; return { value1, value2, value3 } }}，watch: { allFormParam: { handler(val) { let flag = false; for (const key in val) { if (val.hasOwnProperty(key) &amp;&amp; val[key] !== '') { flag = true; } } this.formBtnDisabled = flag; }, deep: true }}","link":"/2018/10/24/vue监听多个data值变化/"},{"title":"redux简易demo","text":"demo 简介通过组件的事件改变 store 中的 state 值，进而改变视图，同时通过调用接口来渲染数据。地址：[https://github.com/MaTonna/demoForRedux] 使用的依赖 react-redux：管理 react 当中的 state，创建一个集中管理的 store redux-thunk： redux 的中间件，使 action 返回一个函数，组件派发事件时可以做一些处理 axios：HTTP 库，创建 http 请求 immutable|redux-immutable： 用于返回新的 state，在 reducer 中用到（不允许修改传递过来的 state） styled-components：写组件样式的库，把每个元素当作组件来写，方便统一组件样式 目录结构 redux flow 思路 创建 store，整合 reducer 在入口 index.js 内引入 APP.js 和用 styled-components 创建的 reset.css 123456789101112//index.js中import { GlobalStyle } from './style';ReactDOM.render( &lt;App&gt; &lt;GlobalStyle /&gt; &lt;/App&gt;, document.getElementById('root'));// style.jsimport { createGlobalStyle } from 'styled-components';export const GlobalStyle = createGlobalStyle`reset.css的内容` 在 store.js 中引入 redux-thunk 作为中间件，在创建 store 时，加入 reducer 来处理 action 1234567import { createStore, compose, applyMiddleware } from 'redux';import reducer from './reducer';import thunk from 'redux-thunk';const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const store = createStore(reducer, composeEnhancers(applyMiddleware(thunk)));export default store; 在统一的 reducer 中使用 redux-immutable 的 combineReducers 来整合各个组件的 reducer 123456import { combineReducers } from 'redux-immutable';import { reducer as headerReducer } from '../common/header/store';export default combineReducers({ header: headerReducer}); 在 APP.js 内引入 store， 使用 react-redux 的 Provider 将 state 传入组件 123456789101112131415import React, { Component } from 'react';import { Provider } from 'react-redux';import Header from './common/header';import store from './store';class App extends Component { render() { return ( &lt;Provider store={store}&gt; &lt;Header /&gt; &lt;/Provider&gt; ); }}export default App; 在组件中创建自己的 reducer，并派发 action 创建组件自己的 reducer 和 actionCreator 123456789101112131415161718192021222324//reducer.jsimport { fromJS } from 'immutable';// 转化为immutable类型数据const defaultState = fromJS({ focused: false});// 默认导出一个函数，接收state和action作为参数export default (state = defaultState, action) =&gt; { //通过接收action.type，来定义不同action的处理方式，例如： if(action.type === 'SEARCH_FOCUS') { //改变state的值并返回一个新的state，触发了组件里的props的变化 return state.set('focused', true); } return state; }};//actionCreator.jsimport axios from 'axios';import { fromJS } from 'immutable';export const searchFocus = () =&gt; ({ type: 'SEARCH_FOCUS'}); 在组件中使用 react-redux 中的 connect 连接 APP.js 的 store，connect 中传入 mapStateToProps 和 mapDispatchToProps，作用分别为映射 store 中的 state 到组件的 props 里，和派发事件的 action 1234567891011121314151617181920212223242526272829303132333435363738import React, { Component } from 'react';import { connect } from 'react-redux';import { HearderWrapper, SearchInput } from './style';//store的index.js中export { reducer, actionCreators }import { actionCreators } from './store';class Hearder extends Component { render() { const { focused, handlerInputFocus, handlerInputBlur } = this.props; return ( &lt;HearderWrapper&gt; //使用connect做了一个绑定 //这里的this.props.handlerInputFocus/focused就是mapDispatchToProps里的handlerInputFocus/focused &lt;SearchInput className={focused ? 'focus' : 'blur'} onFocus={handlerInputFocus}/&gt; &lt;/HearderWrapper&gt; ); }}const mapStateToProps = state =&gt; { return { focused: state.getIn(['header', 'focused']), };};const mapDispatchToProps = dispatch =&gt; { return { //发生事件时派发actionCreator handlerInputFocus() { dispatch(actionCreators.searchFocus()); } };};// 容器组件-负责处理数据逻辑export default connect( mapStateToProps, mapDispatchToProps)(Hearder);","link":"/2018/11/22/redux简易demo/"}],"tags":[],"categories":[]}