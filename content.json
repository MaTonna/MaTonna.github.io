{"pages":[],"posts":[{"title":"2018年度总结-工作篇","text":"       2018 年结束就代表毕业以及工作一年半了，不管是业务熟练程度还是技术掌握都有了自己感知得到的进步。回顾这一年的工作 接触的浏览器平台也从 web 端，PC 软件内嵌 H5，转到了移动端，有 H5，也有 APP 内嵌 H5，还有微信公众号平台，bug 也各不相同 使用的库也从 jquery 转向了 vue+vant 和 react+antd 做的产品也有面向用户、面向销售以及面向内部人员 写的项目也从简单的后台管理系统到对外客户使用的复杂项目，还有复杂的管理后台系统，抽奖、火箭逐帧动画 从只会跟着 PRD 写页面调接口，到自己写一套商城系统，到自己从头主导构建小项目       以上这些都是今年工作上的进步。&nbsp;        除了明显的代码效率和质量上的提高，还有一些心态上的转变，之前很惧怕学习和写 react 项目，担心会因为自己的不熟悉拖延项目进度和降低整体的代码质量，后来由于任务分配而不得不接受要去学习 react 使用的事实（其实一部分是很不喜欢把 html 也写到 js 里，代码整体显得很冗余和笨重）。其实通过组件化来管理自己负责的模块是非常得益的，通过把代码按照模块拆分来其实也降低了复杂度，并且能让自己理清有时非常绕和复杂的需求。&nbsp;        学习的过程非常枯燥和纠结，一方面和自己已掌握的库对比好像又懂了，一方面怀疑自己只会皮毛和简单的使用而不是真正懂他的原理和流程。例如前段时间学习了 redux（博客里有一篇简易的 demo），其实官方的教程有点不是很好理解，然后去找了相关的视频，跟着学习和实践了一次，但是只是单纯的会用，并且记不得调用的过程（只记得简单的应该要建一个 store，然后通过 dispatch 去调用 reducer 里的方法来改变 store 里的值，各个组件通过 connect 共享同一份 store 里的数据，相当于共同的 state，但是并不记得应该如何创建和调用这些流程，每次要写都要去翻之前的代码和教程），后来下定决心搞懂这个 redux 的流程，翻了很多别人的示意图结合之前看的视频，自己画了一个 redux flow 图，这个过程让我想清楚了他的工作流程。并不是说单纯的学到了这个知识点，而是意识到了之前自己的学习方式只是很松散的了解或者使用了一个知识，我也可以认真的去钻研一个点，能够用自己的话讲解并且讲明白这个东西才是真正的懂了。&nbsp;        学习 redux 过了几个礼拜，刚好有个新项目需要我主导负责，并且也负责一整块的需求，其中一个需求是一个带有分组的菜单栏，菜单栏中可以修改分组名，点击展示内容，内容中也可以修改分组和菜单名，我拆分成了几个组件，相互之间传参回调之间特别麻烦，就想改造成 redux 统一管理菜单的信息，之前项目惯例使用 dva，有了前段时间 redux 的知识储备，上手就变得比较简单了，改造起来效率也非常高，还是很有成就感的。&nbsp;        关于负责一个小的新项目，还是有一些感触的。项目在过需求和项目开始之间的空档期，需要考虑技术选型和写基本的公共方法和样式，由于新项目是个数据服务系统，之前参与过别的类似项目，也是沿用之前的那一套 react+antd，但是基本的菜单栏和公共导航是需要自己写的，需要考虑需求和公共部分是否有联系，比如，点击导航如何显示切换页面；菜单栏收起时是否需要在 basicLayout 里传回调，告诉 children 现在的收起状态；还有哪些组件或者样式是可以共用的等等。除了前端几个成员的配合之外，还要和后端和产品的配合，有哪些需求可以更改，哪些可以通过前端自己实现，哪些需要调接口，实现方式是什么，都需要进行商讨，初步了解了对项目整体的一个把控。&nbsp;        由于需要对项目负责，所以要负责给前端伙伴解决一些问题，有别的项目介入，需要分摊时也要接手写了一半的代码，还要解决别人的 bug 和关于公共部分的使用问题，解决别人的 bug 和接手代码都是很需要耐心的事情，也很有技术含量，需要了解别人的具体业务逻辑和 bug 出现场景来推断原因，有些也不是逻辑问题，可能是生命周期和 API 不是很熟练，可以从别人的代码里学到一些技巧和吸取一些教训，是开心和暴躁的体验。接管的话代码风格不同，所以需要重构一下，按照自己的风格去拆分功能，过程是很痛苦的，结果是很有成就的。&nbsp;        还有对一个复杂业务逻辑的思考。由于工作性质，基本上都是用键盘来写字，但是有时候需要静下来仔细思考，用本子和笔来画思路流程，这是个很好的整理思路的方式。比如今年做的一个滚轮抽奖动画，有用户展示端和发起端，思路 发起端流程有：开始按钮-&gt;开始抽奖动画，3s 倒计时，按钮 disabled-&gt;动画停，停止在中奖人处，开始按钮可点击-&gt;抽奖次数结束后按钮消失 动画方面：展示框可显示七条抽奖人，动画滚动 2.5s 后最后一次滚动将中奖人放在中间，动画由快变慢最后停止 数据处理方面：抽奖人少于七人时，重复抽奖人为七人，正常情况下，每一次滚动都截取抽奖人数组的七段，到了末尾再从头截取 调接口方面：一进入展示框就查询所有的抽奖人，点击时调用开始接口，动画停止前查询本轮中奖人并查询是否是最后一次抽奖…等等       诸如此类的复杂需求可以循序渐进分类整理自己的思路。&nbsp;        以上是 2018 的一些教训和总结，如果有想到再接着补充。以下是对今年 2019 的学习展望。&nbsp; 对 ES6 学习的巩固，尤其是块级作用域、函数、数据类型及其方法、迭代器、类、promise、代理反射、模块化进行学习实践，学会项目中常见的处理方法 MVVM 的原理学习，对 vdom、双向绑定、渲染机制有自己的理解，目标是做一个简单的实现 HTTP 方面，有深层次一点的了解 typescript，在学习的基础上，在项目中有稍微复杂一点的实践 拓展类：hybrid，node，数据可视化       具体的计划视情况而定进行调整。&nbsp;        末：希望 2019 还是元气满满的学习和工作，不要轻易放弃呀。","link":"/2019/01/03/2018年度总结-工作篇/"},{"title":"redux简易demo","text":"demo 简介通过组件的事件改变 store 中的 state 值，进而改变视图，同时通过调用接口来渲染数据。地址：https://github.com/MaTonna/demoForRedux 使用的依赖 react-redux：管理 react 当中的 state，创建一个集中管理的 store redux-thunk： redux 的中间件，使 action 返回一个函数，组件派发事件时可以做一些处理 axios：HTTP 库，创建 http 请求 immutable|redux-immutable： 用于返回新的 state，在 reducer 中用到（不允许修改传递过来的 state） styled-components：写组件样式的库，把每个元素当作组件来写，方便统一组件样式 目录结构 redux flow 思路 创建 store，整合 reducer 在入口 index.js 内引入 APP.js 和用 styled-components 创建的 reset.css 123456789101112//index.js中import { GlobalStyle } from './style';ReactDOM.render( &lt;App&gt; &lt;GlobalStyle /&gt; &lt;/App&gt;, document.getElementById('root'));// style.jsimport { createGlobalStyle } from 'styled-components';export const GlobalStyle = createGlobalStyle`reset.css的内容` 在 store.js 中引入 redux-thunk 作为中间件，在创建 store 时，加入 reducer 来处理 action 1234567import { createStore, compose, applyMiddleware } from 'redux';import reducer from './reducer';import thunk from 'redux-thunk';const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const store = createStore(reducer, composeEnhancers(applyMiddleware(thunk)));export default store; 在统一的 reducer 中使用 redux-immutable 的 combineReducers 来整合各个组件的 reducer 123456import { combineReducers } from 'redux-immutable';import { reducer as headerReducer } from '../common/header/store';export default combineReducers({ header: headerReducer}); 在 APP.js 内引入 store， 使用 react-redux 的 Provider 将 state 传入组件 123456789101112131415import React, { Component } from 'react';import { Provider } from 'react-redux';import Header from './common/header';import store from './store';class App extends Component { render() { return ( &lt;Provider store={store}&gt; &lt;Header /&gt; &lt;/Provider&gt; ); }}export default App; 在组件中创建自己的 reducer，并派发 action 创建组件自己的 reducer 和 actionCreator 123456789101112131415161718192021222324//reducer.jsimport { fromJS } from 'immutable';// 转化为immutable类型数据const defaultState = fromJS({ focused: false});// 默认导出一个函数，接收state和action作为参数export default (state = defaultState, action) =&gt; { //通过接收action.type，来定义不同action的处理方式，例如： if(action.type === 'SEARCH_FOCUS') { //改变state的值并返回一个新的state，触发了组件里的props的变化 return state.set('focused', true); } return state; }};//actionCreator.jsimport axios from 'axios';import { fromJS } from 'immutable';export const searchFocus = () =&gt; ({ type: 'SEARCH_FOCUS'}); 在组件中使用 react-redux 中的 connect 连接 APP.js 的 store，connect 中传入 mapStateToProps 和 mapDispatchToProps，作用分别为映射 store 中的 state 到组件的 props 里，和派发事件的 action 1234567891011121314151617181920212223242526272829303132333435363738import React, { Component } from 'react';import { connect } from 'react-redux';import { HearderWrapper, SearchInput } from './style';//store的index.js中export { reducer, actionCreators }import { actionCreators } from './store';class Hearder extends Component { render() { const { focused, handlerInputFocus, handlerInputBlur } = this.props; return ( &lt;HearderWrapper&gt; //使用connect做了一个绑定 //这里的this.props.handlerInputFocus/focused就是mapDispatchToProps里的handlerInputFocus/focused &lt;SearchInput className={focused ? 'focus' : 'blur'} onFocus={handlerInputFocus}/&gt; &lt;/HearderWrapper&gt; ); }}const mapStateToProps = state =&gt; { return { focused: state.getIn(['header', 'focused']), };};const mapDispatchToProps = dispatch =&gt; { return { //发生事件时派发actionCreator handlerInputFocus() { dispatch(actionCreators.searchFocus()); } };};// 容器组件-负责处理数据逻辑export default connect( mapStateToProps, mapDispatchToProps)(Hearder);","link":"/2018/11/22/redux简易demo/"},{"title":"base64 转 blob 通用方法","text":"1234567891011121314dataURItoBlob(base64Data) { let byteString; if (base64Data.split(',')[0].indexOf('base64') &gt;= 0) byteString = atob(base64Data.split(',')[1]); else byteString = unescape(base64Data.split(',')[1]); let mimeString = base64Data .split(',')[0] .split(':')[1] .split(';')[0]; let ia = new Uint8Array(byteString.length); for (let i = 0; i &lt; byteString.length; i++) { ia[i] = byteString.charCodeAt(i); } return new Blob([ia], { type: mimeString });}","link":"/2018/10/24/base64 转 blob 通用方法/"},{"title":"vue监听多个data值变化","text":"操作方法 使用 computed计算属性定义一个变量，用来返回多个 data 值 使用 watch侦听属性控制变量，当变量发生改变时，执行函数，并加上 deep:true 的选项参数，用于发现对象内部值的变化 代码演示使用场景，表单验证时，其中一个控件为空，则不允许点击提交按钮 12345678910111213141516171819202122computed: { allFormParam() { const { value1, value2, value3 } = this; return { value1, value2, value3 } }}，watch: { allFormParam: { handler(val) { let flag = false; for (const key in val) { if (val.hasOwnProperty(key) &amp;&amp; val[key] !== '') { flag = true; } } this.formBtnDisabled = flag; }, deep: true }}","link":"/2018/10/24/vue监听多个data值变化/"},{"title":"express+mlab登录注册","text":"简介和思路 使用express作为node框架，mlab作线上数据库，postman作为调试接口工具； 注册时匹配唯一邮箱，录入用户名、密码（用bcrypt加密过）、邮箱、头像（获取gravatar公认头像），保存数据库成功后返回用户信息； 登录时匹配用户名和密码，匹配成功后返回Bearer token令牌； 访问一个接口，校验传入的authorization是否和登录时的token匹配，匹配通过则返回接口数据，否则响应未通过认证。 githubhttps://github.com/MaTonna/express-manage-web 文件目录 流程演示注册成功后返回用户信息注册时邮箱重复后返回错误信息登录成功后返回token密码错误返回错误信息访问一个返回用户信息的接口，token验证通过才能获取到token验证不通过则默认会返回验证失败 用到的依赖和工具 工具：postman 发送请求和接收响应，用于调接口 “bcrypt”: “^3.0.2” 对注册密码进行加密 “body-parser”: “^1.18.3” 对post请求的请求体进行解析 “express”: “^4.16.4” nodejs框架，设置中间件响应HTTP请求，定义路由执行HTTP请求动作，给HTML页面传递参数 “gravatar”: “^1.6.0” 全球公认头像 “jsonwebtoken”: “^8.3.0” 跨域认证解决方案，用于生成token令牌，服务端认定用户身份 “mongoose”: “^5.3.8” 对mongodb进行便捷操作的对象模型工具 “passport”: “^0.4.0” 用于验证登录信息，如果token通过才能访问接口 “passport-jwt”: “^4.0.0” server.js功能：配置/连接数据库，配置访问API的中间件，配置/监听端口号等等。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const express = require('express');const mongoose = require('mongoose');const bodyParser = require('body-parser');const passport = require('passport');// 接口apiconst users = require('./routers/api/users');const profiles = require('./routers/api/profiles');const app = express();// 使用body-parser中间件app.use(bodyParser.urlencoded({ extended: false }));app.use(bodyParser.json());// 使用中间件使用users,访问/api/users时获取到usersapp.use('/api/users', users);app.use('/api/profiles', profiles);// 链接数据库const db = require('./config/keys').mongoURL;mongoose .connect( db, { useNewUrlParser: true } ) .then(() =&gt; { console.log('connect'); }) .catch(err =&gt; { console.log(err); });// 初始化passport// passport的配置app.use(passport.initialize());require('./config/passport')(passport);// 访问主页时给页面发送数据app.get('/', (req, res) =&gt; { res.send('hello world');});const port = process.env.PORT || 5000;app.listen(port, () =&gt; { console.log('server start');}); users.js功能：接口代码，配置router123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105const express = require('express');const router = express.Router();const bcrypt = require('bcrypt');const jwt = require('jsonwebtoken');const gravatar = require('gravatar');const keys = require('../../config/keys');const passport = require('passport');const User = require('../../models/User');// $router POST api/users/register// @desc 返回请求的json数据// @access publicrouter.post('/register', (req, res) =&gt; { // 查询一条记录 User.findOne({ email: req.body.email }).then(user =&gt; { if (user) { return res.status(400).json('邮箱已被注册'); } else { var avatar = gravatar.url('req.body.email', { s: '200', r: 'pg', d: 'mm' }); const newUser = new User({ avatar, name: req.body.name, email: req.body.email, password: req.body.password, identity: req.body.identity }); // 用bcrypt对密码进行加密 bcrypt.genSalt(10, function(err, salt) { bcrypt.hash(newUser.password, salt, (err, hash) =&gt; { if (err) { throw err; } // hash为加密后的密码 newUser.password = hash; // 调用存储方法 newUser .save() .then(user =&gt; { res.json(user); }) .catch(err =&gt; { console.log(err); }); }); }); } });});// $router POST api/users/login// @desc 返回token jwt password// @access publicrouter.post('/login', (req, res) =&gt; { const email = req.body.email; const password = req.body.password; User.findOne({ email }).then(user =&gt; { if (!user) { return res.status(404).json('用户不存在'); } // 密码匹配 bcrypt.compare(password, user.password).then(isMatch =&gt; { if (isMatch) { // 规则，加密名字，过期时间，回调 const rule = { id: user.id, name: user.name, avatar: user.avatar, identity: user.identity }; // 登录成功后返回token，相当于一个令牌，只有令牌校验成功，才可以获取想要的数据 jwt.sign(rule, keys.secretOrKey, { expiresIn: 3600 }, (err, token) =&gt; { if (err) { throw err; } res.json({ success: true, // 必须加Bearer token: 'Bearer ' + token }); }); // res.json({ msg: 'success' }); } else { return res.status(404).json('密码错误'); } }); });});// $router GET api/users/current// @desc 返回current user// @access privaterouter.get('/current', passport.authenticate('jwt', { session: false }), (req, res) =&gt; { res.json({ id: req.user.id, name: req.user.name, email: req.user.email, identity: req.user.identity });});module.exports = router; User.js功能：配置mongoose的模型12345678910111213141516171819202122232425262728293031const mongoose = require('mongoose');const Schema = mongoose.Schema;// 创建模型和所需要的字段const UserSchema = new Schema({ name: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, avatar: { type: String }, identity: { type: String, required: true }, data: { type: Date, default: Date.now }});module.exports = User = mongoose.model('users', UserSchema); passport.js12345678910111213141516171819202122232425262728const JwtStrategy = require('passport-jwt').Strategy, ExtractJwt = require('passport-jwt').ExtractJwt;const mongoose = require('mongoose');const User = mongoose.model('users');const keys = require('../config/keys');const opts = {};opts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();opts.secretOrKey = keys.secretOrKey;// passport验证tokenmodule.exports = passport =&gt; { passport.use( new JwtStrategy(opts, (jwt_payload, done) =&gt; { User.findById(jwt_payload.id) .then(user =&gt; { if (user) { return done(null, user); } else { return done(null, false); } }) .catch(err =&gt; { console.log(err); }); }) );}; keys.js1234module.exports = { mongoURL: 'mongodb://manager-web:twj123456@ds147233.mlab.com:47233/resful-api-prod', secretOrKey: 'secret'};","link":"/2018/11/02/node试水（一）express+mlab登录注册/"}],"tags":[{"name":"个人总结","slug":"个人总结","link":"/tags/个人总结/"},{"name":"redux","slug":"redux","link":"/tags/redux/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"node","slug":"node","link":"/tags/node/"}],"categories":[{"name":"年度总结","slug":"年度总结","link":"/categories/年度总结/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"tips","slug":"tips","link":"/categories/tips/"}]}