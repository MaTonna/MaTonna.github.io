{"pages":[],"posts":[{"title":"2018年度总结-工作篇","text":"       2018 年结束就代表毕业以及工作一年半了，不管是业务熟练程度还是技术掌握都有了自己感知得到的进步。回顾这一年的工作 接触的浏览器平台也从 web 端，PC 软件内嵌 H5，转到了移动端，有 H5，也有 APP 内嵌 H5，还有微信公众号平台，bug 也各不相同 使用的库也从 jquery 转向了 vue+vant 和 react+antd 做的产品也有面向用户、面向销售以及面向内部人员 写的项目也从简单的后台管理系统到对外客户使用的复杂项目，还有复杂的管理后台系统，抽奖、火箭逐帧动画 从只会跟着 PRD 写页面调接口，到自己写一套商城系统，到自己从头主导构建小项目       以上这些都是今年工作上的进步。&nbsp;        除了明显的代码效率和质量上的提高，还有一些心态上的转变，之前很惧怕学习和写 react 项目，担心会因为自己的不熟悉拖延项目进度和降低整体的代码质量，后来由于任务分配而不得不接受要去学习 react 使用的事实（其实一部分是很不喜欢把 html 也写到 js 里，代码整体显得很冗余和笨重）。其实通过组件化来管理自己负责的模块是非常得益的，通过把代码按照模块拆分来其实也降低了复杂度，并且能让自己理清有时非常绕和复杂的需求。&nbsp;        学习的过程非常枯燥和纠结，一方面和自己已掌握的库对比好像又懂了，一方面怀疑自己只会皮毛和简单的使用而不是真正懂他的原理和流程。例如前段时间学习了 redux（博客里有一篇简易的 demo），其实官方的教程有点不是很好理解，然后去找了相关的视频，跟着学习和实践了一次，但是只是单纯的会用，并且记不得调用的过程（只记得简单的应该要建一个 store，然后通过 dispatch 去调用 reducer 里的方法来改变 store 里的值，各个组件通过 connect 共享同一份 store 里的数据，相当于共同的 state，但是并不记得应该如何创建和调用这些流程，每次要写都要去翻之前的代码和教程），后来下定决心搞懂这个 redux 的流程，翻了很多别人的示意图结合之前看的视频，自己画了一个 redux flow 图，这个过程让我想清楚了他的工作流程。并不是说单纯的学到了这个知识点，而是意识到了之前自己的学习方式只是很松散的了解或者使用了一个知识，我也可以认真的去钻研一个点，能够用自己的话讲解并且讲明白这个东西才是真正的懂了。&nbsp;        学习 redux 过了几个礼拜，刚好有个新项目需要我主导负责，并且也负责一整块的需求，其中一个需求是一个带有分组的菜单栏，菜单栏中可以修改分组名，点击展示内容，内容中也可以修改分组和菜单名，我拆分成了几个组件，相互之间传参回调之间特别麻烦，就想改造成 redux 统一管理菜单的信息，之前项目惯例使用 dva，有了前段时间 redux 的知识储备，上手就变得比较简单了，改造起来效率也非常高，还是很有成就感的。&nbsp;        关于负责一个小的新项目，还是有一些感触的。项目在过需求和项目开始之间的空档期，需要考虑技术选型和写基本的公共方法和样式，由于新项目是个数据服务系统，之前参与过别的类似项目，也是沿用之前的那一套 react+antd，但是基本的菜单栏和公共导航是需要自己写的，需要考虑需求和公共部分是否有联系，比如，点击导航如何显示切换页面；菜单栏收起时是否需要在 basicLayout 里传回调，告诉 children 现在的收起状态；还有哪些组件或者样式是可以共用的等等。除了前端几个成员的配合之外，还要和后端和产品的配合，有哪些需求可以更改，哪些可以通过前端自己实现，哪些需要调接口，实现方式是什么，都需要进行商讨，初步了解了对项目整体的一个把控。&nbsp;        由于需要对项目负责，所以要负责给前端伙伴解决一些问题，有别的项目介入，需要分摊时也要接手写了一半的代码，还要解决别人的 bug 和关于公共部分的使用问题，解决别人的 bug 和接手代码都是很需要耐心的事情，也很有技术含量，需要了解别人的具体业务逻辑和 bug 出现场景来推断原因，有些也不是逻辑问题，可能是生命周期和 API 不是很熟练，可以从别人的代码里学到一些技巧和吸取一些教训，是开心和暴躁的体验。接管的话代码风格不同，所以需要重构一下，按照自己的风格去拆分功能，过程是很痛苦的，结果是很有成就的。&nbsp;        还有对一个复杂业务逻辑的思考。由于工作性质，基本上都是用键盘来写字，但是有时候需要静下来仔细思考，用本子和笔来画思路流程，这是个很好的整理思路的方式。比如今年做的一个滚轮抽奖动画，有用户展示端和发起端，思路 发起端流程有：开始按钮-&gt;开始抽奖动画，3s 倒计时，按钮 disabled-&gt;动画停，停止在中奖人处，开始按钮可点击-&gt;抽奖次数结束后按钮消失 动画方面：展示框可显示七条抽奖人，动画滚动 2.5s 后最后一次滚动将中奖人放在中间，动画由快变慢最后停止 数据处理方面：抽奖人少于七人时，重复抽奖人为七人，正常情况下，每一次滚动都截取抽奖人数组的七段，到了末尾再从头截取 调接口方面：一进入展示框就查询所有的抽奖人，点击时调用开始接口，动画停止前查询本轮中奖人并查询是否是最后一次抽奖…等等       诸如此类的复杂需求可以循序渐进分类整理自己的思路。&nbsp;        以上是 2018 的一些教训和总结，如果有想到再接着补充。以下是对今年 2019 的学习展望。&nbsp; 对 ES6 学习的巩固，尤其是块级作用域、函数、数据类型及其方法、迭代器、类、promise、代理反射、模块化进行学习实践，学会项目中常见的处理方法 MVVM 的原理学习，对 vdom、双向绑定、渲染机制有自己的理解，目标是做一个简单的实现 HTTP 方面，有深层次一点的了解 typescript，在学习的基础上，在项目中有稍微复杂一点的实践 拓展类：hybrid，node，数据可视化       具体的计划视情况而定进行调整。&nbsp;        末：希望 2019 还是元气满满的学习和工作，不要轻易放弃呀。","link":"/2019/01/03/2018年度总结-工作篇/"},{"title":"JS 异步编程及常考面试题","text":"1. 回调函数       面试题：回调函数有什么缺点？如何解决回调地狱问题？        回调容易写出回调地狱，根本问题是嵌套函数存在耦合性，一旦有所改动就会牵一发而动全身，并且嵌套函数多了会很难处理错误。回调函数不能使用 try catch 捕获错误，不能直接 return。        如何解决回调地狱的问题？：用 Generator/Promise/async&amp;&amp;await 来改善。 2. Generator       面试题：你理解的 Generator 是什么？？        Generator 是生成器，一种返回迭代器（是一种特殊对象，具有一些专门为迭代过程设计的专有接口，所有的迭代器对象都有 next()方法，每次调用都会返回结果对象{value:’xxx’,done:true/false}）的函数，用处是可以控制函数的执行，通过 function 关键字后的*来表示，函数中会使用 yield 关键字。 12345678910function *foo(x) { let y = 2 * (yield (x + 1)); let z = yield (y / 3); return (x + y + z);}let it = foo(5);console.log(it.next()); // 执行yield(x+1) =&gt; 输出{value:6, done:false}console.log(it.next(12)); // 执行yield(y/3)，传入的12是上一个yield的返回值（如果不传参数，上一个yield是undefined），即 yield(x+1) = 12 =&gt; y = 2*12 = 24; =&gt; 输出yield(y/3) = {value:8, done:false}console.log(it.next(13)); // 执行x+y+z，输入的13是yield(y/3) =&gt; z = 13 =&gt; 输出x+y+z = 5+24+13 = 42        使用 Generator 来解决回调地狱的问题： 123456789function *fetch() { yield ajax(url1 ,() =&gt; {}) yield ajax(url2 ,() =&gt; {}) yield ajax(url3 ,() =&gt; {})}let it = fetch();let result1 = it.next();let result2 = it.next();let result3 = it.next(); 3.Promise       面试题：Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？ 特点和优缺点： Promise 有三种状态：等待中(pending)、完成了(resolved)、拒绝了(rejected)，一旦从等待状态变成了其他状态就不能更改状态了 1234new Promise((resolve, reject) =&gt; { resolve(&apos;success&apos;) reject(&apos;reject&apos;) // 无效}) 在构造 Promise 的时候，构造函数内部的代码是立即执行的 123456new Promise((resolve, reject) =&gt; { console.log(&apos;new Promise&apos;); resolve(&apos;success&apos;);})console.log(&apos;finish&apos;);// new Promise -&gt; finish        缺点：无法取消 Promise，错误需要通过回调函数捕获。 Promise 实现了链式调用，每次调用 then 之后返回一个全新的Promise（因为状态不可变），如果在 then 中使用了 return，那么 return 的值会被 Promise.resolve()包装。 使用 Promise 来解决回调地狱的问题： 12345678910ajax(url) .then(res =&gt; { console.log(res) return ajax(url1) }).then(res =&gt; { console.log(res) return ajax(url2) }).then(res =&gt; { return console.log(res) }) 4.async 及 await       面试题：async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？ await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator。一个函数如果加上 async，那么函数就会返回一个 Promise，async 就是将函数返回值用 RESOLVE 包裹了，和 then 中处理返回值一样，并且 await 只能配套 async 使用 相比于直接使用 Promise，处理掉了 then 的调用链，优雅的解决了回调地狱的问题 1234567async function test() { // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式 // 如果有依赖性的话，其实就是解决回调地狱的例子了 await fetch(url) await fetch(url1) await fetch(url2)} 缺点：await 将异步代码改造成了同步代码，如果多个异步没有依赖性，使用了 await 会导致性能上的降低。(一个执行完成才会执行下一个)        await 创建 promise，所以 await 之后的代码才是异步的。","link":"/2019/01/19/JS 异步编程及常考面试题/"},{"title":"base64 转 blob 通用方法","text":"1234567891011121314dataURItoBlob(base64Data) { let byteString; if (base64Data.split(',')[0].indexOf('base64') &gt;= 0) byteString = atob(base64Data.split(',')[1]); else byteString = unescape(base64Data.split(',')[1]); let mimeString = base64Data .split(',')[0] .split(':')[1] .split(';')[0]; let ia = new Uint8Array(byteString.length); for (let i = 0; i &lt; byteString.length; i++) { ia[i] = byteString.charCodeAt(i); } return new Blob([ia], { type: mimeString });}","link":"/2018/10/24/base64 转 blob 通用方法/"},{"title":"实现一个Promise","text":"简易版 Promise 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const PENDING = &apos;pending&apos;;const RESOLVED = &apos;resolved&apos;;const REJECTED = &apos;rejected&apos;;function MyPromise(fn) { const that = this; // 代码可能会异步执行，用于获取正确的this对象 that.state = PENDING; that.value = null; // 用于保存resolve或者reject中传入的值 that.resolvedCallbacks = []; that.rejectedCallbacks = []; // 保存then中的回调，状态改变时使用 function resolve(value) { //只有等待状态才可以改变状态 if (that.state === PENDING) { that.state = RESOLVED; that.value = value; // 调用then的时候value需要往下传递 that.resolvedCallbacks.map(cb =&gt; cb(that.value)); // 执行回调 } } function reject(value) { if (that.state === PENDING) { that.state = REJECTED; that.value = value; that.rejectedCallbacks.map(cb =&gt; cb(that.value)); } } // 执行Promise中传入的函数 try { fn(resolve, reject); } catch (e) { reject(e); }}MyPromise.prototype.then = function(onFulfilled, onRejected) { const that = this; // 检测参数是否是函数类型，如果不是则创建一个函数赋值给对应的参数 onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : v =&gt; v; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : r =&gt; { throw new Error(r); }; if (that.state === PENDING) { that.resolvedCallbacks.push(onFulfilled); that.rejectedCallbacks.push(onRejected); } if (that.state === RESOLVED) { onFulfilled(that.value); } if (that.state === REJECTED) { onRejected(that.value); }};// 调用new MyPromise((resolve, reject) =&gt; { let a = 0; if (a === 1) { resolve(a); } else { reject(&apos;error啦&apos;); }}).then( value =&gt; { console.log(&apos;success&apos;, value); }, err =&gt; { console.log(&apos;err&apos;, err); }); 完整版 Promise(https://github.com/xieranmaya/blog/issues/2)通过了 promises-aplus-tests 的测试npm i -g promises-aplus-testspromises-aplus-tests Promise.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177try { module.exports = Promise;} catch (e) {}function Promise(executor) { var self = this; self.status = &apos;pending&apos;; self.onResolvedCallback = []; self.onRejectedCallback = []; function resolve(value) { if (value instanceof Promise) { return value.then(resolve, reject); } setTimeout(function() { // 异步执行所有的回调函数 if (self.status === &apos;pending&apos;) { self.status = &apos;resolved&apos;; self.data = value; for (var i = 0; i &lt; self.onResolvedCallback.length; i++) { self.onResolvedCallback[i](value); } } }); } function reject(reason) { setTimeout(function() { // 异步执行所有的回调函数 if (self.status === &apos;pending&apos;) { self.status = &apos;rejected&apos;; self.data = reason; for (var i = 0; i &lt; self.onRejectedCallback.length; i++) { self.onRejectedCallback[i](reason); } } }); } try { executor(resolve, reject); } catch (reason) { reject(reason); }}function resolvePromise(promise2, x, resolve, reject) { var then; var thenCalledOrThrow = false; if (promise2 === x) { return reject(new TypeError(&apos;Chaining cycle detected for promise!&apos;)); } if (x instanceof Promise) { if (x.status === &apos;pending&apos;) { //because x could resolved by a Promise Object x.then(function(v) { resolvePromise(promise2, v, resolve, reject); }, reject); } else { //but if it is resolved, it will never resolved by a Promise Object but a static value; x.then(resolve, reject); } return; } if (x !== null &amp;&amp; (typeof x === &apos;object&apos; || typeof x === &apos;function&apos;)) { try { then = x.then; //because x.then could be a getter if (typeof then === &apos;function&apos;) { then.call( x, function rs(y) { if (thenCalledOrThrow) return; thenCalledOrThrow = true; return resolvePromise(promise2, y, resolve, reject); }, function rj(r) { if (thenCalledOrThrow) return; thenCalledOrThrow = true; return reject(r); } ); } else { resolve(x); } } catch (e) { if (thenCalledOrThrow) return; thenCalledOrThrow = true; return reject(e); } } else { resolve(x); }}Promise.prototype.then = function(onResolved, onRejected) { var self = this; var promise2; onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function(v) { return v; }; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function(r) { throw r; }; if (self.status === &apos;resolved&apos;) { return (promise2 = new Promise(function(resolve, reject) { setTimeout(function() { // 异步执行onResolved try { var x = onResolved(self.data); resolvePromise(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.status === &apos;rejected&apos;) { return (promise2 = new Promise(function(resolve, reject) { setTimeout(function() { // 异步执行onRejected try { var x = onRejected(self.data); resolvePromise(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.status === &apos;pending&apos;) { return (promise2 = new Promise(function(resolve, reject) { self.onResolvedCallback.push(function(value) { try { var x = onResolved(value); resolvePromise(promise2, x, resolve, reject); } catch (r) { reject(r); } }); self.onRejectedCallback.push(function(reason) { try { var x = onRejected(reason); resolvePromise(promise2, x, resolve, reject); } catch (r) { reject(r); } }); })); }};Promise.prototype.catch = function(onRejected) { return this.then(null, onRejected);};Promise.deferred = Promise.defer = function() { var dfd = {}; dfd.promise = new Promise(function(resolve, reject) { dfd.resolve = resolve; dfd.reject = reject; }); return dfd;};","link":"/2019/01/22/实现一个Promise/"},{"title":"ES6知识点及常考面试题","text":"1. var、let 及 const 区别       面试题：什么是提升？什么是暂时性死区？var、let 及 const 区别？        在变量声明之前使用变量叫做变量提升，并且提升的是声明，使用 var 声明的变量会被提升到作用域的顶部。 1234567var a = 10;var a ;console.log(a) //10//相当于var a;var a;a = 10;        函数也会被提升，并且优于变量提升，函数提升会把整个函数挪到作用域顶部。 123456789101112var a = 1let b = 1const c = 1console.log(window.a) // 1console.log(window.b) // undefinedconsole.log(window. c) // undefinedfunction test(){ console.log(a) let a}test() // 报错：a is not defined        总结： let 和 const 存在暂时性死区，不能在声明前使用变量 在全局作用域下使用 let 和 const 声明变量，变量不会被挂载到 window 上 let 和 const 声明变量使用的是块作用域 let 和 const 不允许重复定义 let 在循环中引入了新的环境变量，针对每次迭代都会创建新的作用域 const 声明的变量不能再次赋值 2. 原型继承和 class 继承       面试题：原型如何实现继承？Class 如何实现继承？Class 本质是什么？ 1234567//父类function Parent(value) { this.val = value;}Parent.prototype.getValue = function() { console.log(this.val);} 组合继承 12345678function Child(value) { Parent.call(this, value); //在子类的构造函数中继承父类的属性}Child.prototype = new Parent(); //改变子类的原型为new Parent()来继承父类的函数const child = new Child(1);child.getValue(); // 1child instanceof Parent // true        缺点：继承父类函数时调用了父类构造函数，导致子类的原型上多了不需要的父类属性，内存上存在浪费。 寄生组合继承 1234567891011function Child(value) { Parent.call(this, value);}Child.prototype = Object.create(Parent.prototype, { constructor:{ value: Child, // 将父类的原型赋给子类，将构造函数设置为子类 enumerable: false, writable: true, configurable: true }}) class 继承 123456class Child extends Parent { constructor(value) { super(value); // 必须调用，继承父类属性，相当于Parent.call(this, value) this.val = value; }}        class 本质是函数，JS 中并不存在类 3. 模块化       面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？        优点：解决命名冲突、提供复用性、提高代码可维护性       实现模块化的方式： 立即执行函数 123(function(globalVariable) { // 声明各种变量、函数都不会污染全局作用域})(globalVariable) AMD/CMD 12345678910111213// AMDdefine([&apos;./a&apos;, &apos;./b&apos;], function(a, b) { // 加载模块完毕可以使用 a.do() b.do()})// CMDdefine(function(require, exports, module) { // 加载模块 // 可以把 require 写在函数体的任意地方实现延迟加载 var a = require(&apos;./a&apos;) a.doSomething()}) CommonJS 12345678910// a.jsmodule.exports = { a: 1}// orexports.a = 1// b.jsvar module = require(&apos;./a.js&apos;)module.a // -&gt; log 1 ES Module 异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化 会编译成 require/exports 来执行的 123456// 引入模块 APIimport XXX from &apos;./a.js&apos;import { XXX } from &apos;./a.js&apos;// 导出模块 APIexport function a() {}export default function() {} 4. Proxy       面试题：Proxy 可以实现什么功能？        解释： 代理（Proxy）是一种可以拦截并改变底层 JavaScript 引擎操作的包装器，通过暴露内部运作的对象，从而可以创建内建的对象 底层被拦截后会触发响应特定操作的陷阱函数 反射 API 以 Reflect 对象的形式存在，Reflect 对象中的方法的默认特性和相同的底层操作保持一致，代理可以覆写这些操作，每个代理陷阱对应一个命名和参数都相同的 Reflect 方法 代理和反射的关系举例：改写内置 get 方法，代理负责拦截原来的 get 方法，并触发陷阱函数修改 get 的读取属性值特性，反射就是原来的内置方法，即 Reflect.get()是之前的 get 方法       使用 set 陷阱验证属性： 1234567891011121314151617181920let target = { name: &quot;target&quot;}let proxy = new Proxy(target, { //set陷阱 set(trapTarget, key, value, receiver) { //忽略已有属性 if(!trapTarget.hasOwnProperty(key)) { if(isNaN(value)) { throw new TypeError(&apos;属性必须为数字&apos;); } } return Reflect.set(trapTarget, key, value, receiver); //反射，用于使用内置set方法添加属性 }})proxy.count = 1; // 此时set陷阱被调用，是数字所以可以赋值console.log(target.count) // 1proxy.name = &apos;proxy&apos;;console.log(target.name) // &apos;proxy&apos;，target已有name属性，所以可以赋值proxy.notNumber = &apos;a&apos;; // Uncaught TypeError: 属性必须为数字，给不存在的属性赋值并且值不是数字则抛错        实现简单版响应式： 12345678910111213141516171819202122232425262728let onWatch = (obj, setBind, getLogger) =&gt; { let handler = { //set陷阱 set(target, property, value, receiver) { setBind(value, property) return Reflect.set(target, property, value) }, //get陷阱 get(target, property, receiver) { getLogger(target, property) return Reflect.get(target, property, receiver) } } return new Proxy(obj, handler)}let obj = { a: 1 }let p = onWatch( obj, (v, property) =&gt; { console.log(`监听到属性${property}改变为${v}`) }, (target, property) =&gt; { console.log(`&apos;${property}&apos; = ${target[property]}`) })p.a = 2 // 监听到属性a改变p.a // &apos;a&apos; = 2        应用举例：用 get 陷阱验证对象结构、用 has 陷阱隐藏已有属性、用 deleteProperty 陷阱防止删除属性 4. 数组方法       面试题：map, filter, reduce 各自有什么作用？ map：[].map((当前索引元素，索引，原数组) =&gt; {})，遍历原数组，每个元素做相同的操作，生成一个新数组 1[1, 2, 3].map(v =&gt; v + 1) // -&gt; [2, 3, 4] filter：[].filter((当前索引元素，索引，原数组) =&gt; {})，遍历原数组时将返回 true 的元素放入新数组 1let newArray = [1, 2, 4, 6].filter(item =&gt; item !== 6) // [1,2,4] reduce：[].reduce((累计值、当前元素、当前索引、原数组) =&gt; {}, 初始值)，将数组中的元素通过回调函数最终转换为一个值 12//在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入const sum = [1, 2, 3].reduce((acc, current) =&gt; acc + current, 0) // 累加为6","link":"/2019/01/17/ES6知识点及常考面试题/"},{"title":"express+mlab登录注册","text":"简介和思路 使用express作为node框架，mlab作线上数据库，postman作为调试接口工具； 注册时匹配唯一邮箱，录入用户名、密码（用bcrypt加密过）、邮箱、头像（获取gravatar公认头像），保存数据库成功后返回用户信息； 登录时匹配用户名和密码，匹配成功后返回Bearer token令牌； 访问一个接口，校验传入的authorization是否和登录时的token匹配，匹配通过则返回接口数据，否则响应未通过认证。 githubhttps://github.com/MaTonna/express-manage-web 文件目录 流程演示注册成功后返回用户信息注册时邮箱重复后返回错误信息登录成功后返回token密码错误返回错误信息访问一个返回用户信息的接口，token验证通过才能获取到token验证不通过则默认会返回验证失败 用到的依赖和工具 工具：postman 发送请求和接收响应，用于调接口 “bcrypt”: “^3.0.2” 对注册密码进行加密 “body-parser”: “^1.18.3” 对post请求的请求体进行解析 “express”: “^4.16.4” nodejs框架，设置中间件响应HTTP请求，定义路由执行HTTP请求动作，给HTML页面传递参数 “gravatar”: “^1.6.0” 全球公认头像 “jsonwebtoken”: “^8.3.0” 跨域认证解决方案，用于生成token令牌，服务端认定用户身份 “mongoose”: “^5.3.8” 对mongodb进行便捷操作的对象模型工具 “passport”: “^0.4.0” 用于验证登录信息，如果token通过才能访问接口 “passport-jwt”: “^4.0.0” server.js功能：配置/连接数据库，配置访问API的中间件，配置/监听端口号等等。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const express = require('express');const mongoose = require('mongoose');const bodyParser = require('body-parser');const passport = require('passport');// 接口apiconst users = require('./routers/api/users');const profiles = require('./routers/api/profiles');const app = express();// 使用body-parser中间件app.use(bodyParser.urlencoded({ extended: false }));app.use(bodyParser.json());// 使用中间件使用users,访问/api/users时获取到usersapp.use('/api/users', users);app.use('/api/profiles', profiles);// 链接数据库const db = require('./config/keys').mongoURL;mongoose .connect( db, { useNewUrlParser: true } ) .then(() =&gt; { console.log('connect'); }) .catch(err =&gt; { console.log(err); });// 初始化passport// passport的配置app.use(passport.initialize());require('./config/passport')(passport);// 访问主页时给页面发送数据app.get('/', (req, res) =&gt; { res.send('hello world');});const port = process.env.PORT || 5000;app.listen(port, () =&gt; { console.log('server start');}); users.js功能：接口代码，配置router123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105const express = require('express');const router = express.Router();const bcrypt = require('bcrypt');const jwt = require('jsonwebtoken');const gravatar = require('gravatar');const keys = require('../../config/keys');const passport = require('passport');const User = require('../../models/User');// $router POST api/users/register// @desc 返回请求的json数据// @access publicrouter.post('/register', (req, res) =&gt; { // 查询一条记录 User.findOne({ email: req.body.email }).then(user =&gt; { if (user) { return res.status(400).json('邮箱已被注册'); } else { var avatar = gravatar.url('req.body.email', { s: '200', r: 'pg', d: 'mm' }); const newUser = new User({ avatar, name: req.body.name, email: req.body.email, password: req.body.password, identity: req.body.identity }); // 用bcrypt对密码进行加密 bcrypt.genSalt(10, function(err, salt) { bcrypt.hash(newUser.password, salt, (err, hash) =&gt; { if (err) { throw err; } // hash为加密后的密码 newUser.password = hash; // 调用存储方法 newUser .save() .then(user =&gt; { res.json(user); }) .catch(err =&gt; { console.log(err); }); }); }); } });});// $router POST api/users/login// @desc 返回token jwt password// @access publicrouter.post('/login', (req, res) =&gt; { const email = req.body.email; const password = req.body.password; User.findOne({ email }).then(user =&gt; { if (!user) { return res.status(404).json('用户不存在'); } // 密码匹配 bcrypt.compare(password, user.password).then(isMatch =&gt; { if (isMatch) { // 规则，加密名字，过期时间，回调 const rule = { id: user.id, name: user.name, avatar: user.avatar, identity: user.identity }; // 登录成功后返回token，相当于一个令牌，只有令牌校验成功，才可以获取想要的数据 jwt.sign(rule, keys.secretOrKey, { expiresIn: 3600 }, (err, token) =&gt; { if (err) { throw err; } res.json({ success: true, // 必须加Bearer token: 'Bearer ' + token }); }); // res.json({ msg: 'success' }); } else { return res.status(404).json('密码错误'); } }); });});// $router GET api/users/current// @desc 返回current user// @access privaterouter.get('/current', passport.authenticate('jwt', { session: false }), (req, res) =&gt; { res.json({ id: req.user.id, name: req.user.name, email: req.user.email, identity: req.user.identity });});module.exports = router; User.js功能：配置mongoose的模型12345678910111213141516171819202122232425262728293031const mongoose = require('mongoose');const Schema = mongoose.Schema;// 创建模型和所需要的字段const UserSchema = new Schema({ name: { type: String, required: true }, email: { type: String, required: true }, password: { type: String, required: true }, avatar: { type: String }, identity: { type: String, required: true }, data: { type: Date, default: Date.now }});module.exports = User = mongoose.model('users', UserSchema); passport.js12345678910111213141516171819202122232425262728const JwtStrategy = require('passport-jwt').Strategy, ExtractJwt = require('passport-jwt').ExtractJwt;const mongoose = require('mongoose');const User = mongoose.model('users');const keys = require('../config/keys');const opts = {};opts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();opts.secretOrKey = keys.secretOrKey;// passport验证tokenmodule.exports = passport =&gt; { passport.use( new JwtStrategy(opts, (jwt_payload, done) =&gt; { User.findById(jwt_payload.id) .then(user =&gt; { if (user) { return done(null, user); } else { return done(null, false); } }) .catch(err =&gt; { console.log(err); }); }) );}; keys.js1234module.exports = { mongoURL: 'mongodb://manager-web:twj123456@ds147233.mlab.com:47233/resful-api-prod', secretOrKey: 'secret'};","link":"/2018/11/02/node试水（一）express+mlab登录注册/"},{"title":"redux简易demo","text":"demo 简介通过组件的事件改变 store 中的 state 值，进而改变视图，同时通过调用接口来渲染数据。地址：https://github.com/MaTonna/demoForRedux 使用的依赖 react-redux：管理 react 当中的 state，创建一个集中管理的 store redux-thunk： redux 的中间件，使 action 返回一个函数，组件派发事件时可以做一些处理 axios：HTTP 库，创建 http 请求 immutable|redux-immutable： 用于返回新的 state，在 reducer 中用到（不允许修改传递过来的 state） styled-components：写组件样式的库，把每个元素当作组件来写，方便统一组件样式 目录结构 redux flow 思路 创建 store，整合 reducer 在入口 index.js 内引入 APP.js 和用 styled-components 创建的 reset.css 123456789101112//index.js中import { GlobalStyle } from './style';ReactDOM.render( &lt;App&gt; &lt;GlobalStyle /&gt; &lt;/App&gt;, document.getElementById('root'));// style.jsimport { createGlobalStyle } from 'styled-components';export const GlobalStyle = createGlobalStyle`reset.css的内容` 在 store.js 中引入 redux-thunk 作为中间件，在创建 store 时，加入 reducer 来处理 action 1234567import { createStore, compose, applyMiddleware } from 'redux';import reducer from './reducer';import thunk from 'redux-thunk';const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const store = createStore(reducer, composeEnhancers(applyMiddleware(thunk)));export default store; 在统一的 reducer 中使用 redux-immutable 的 combineReducers 来整合各个组件的 reducer 123456import { combineReducers } from 'redux-immutable';import { reducer as headerReducer } from '../common/header/store';export default combineReducers({ header: headerReducer}); 在 APP.js 内引入 store， 使用 react-redux 的 Provider 将 state 传入组件 123456789101112131415import React, { Component } from 'react';import { Provider } from 'react-redux';import Header from './common/header';import store from './store';class App extends Component { render() { return ( &lt;Provider store={store}&gt; &lt;Header /&gt; &lt;/Provider&gt; ); }}export default App; 在组件中创建自己的 reducer，并派发 action 创建组件自己的 reducer 和 actionCreator 123456789101112131415161718192021222324//reducer.jsimport { fromJS } from 'immutable';// 转化为immutable类型数据const defaultState = fromJS({ focused: false});// 默认导出一个函数，接收state和action作为参数export default (state = defaultState, action) =&gt; { //通过接收action.type，来定义不同action的处理方式，例如： if(action.type === 'SEARCH_FOCUS') { //改变state的值并返回一个新的state，触发了组件里的props的变化 return state.set('focused', true); } return state; }};//actionCreator.jsimport axios from 'axios';import { fromJS } from 'immutable';export const searchFocus = () =&gt; ({ type: 'SEARCH_FOCUS'}); 在组件中使用 react-redux 中的 connect 连接 APP.js 的 store，connect 中传入 mapStateToProps 和 mapDispatchToProps，作用分别为映射 store 中的 state 到组件的 props 里，和派发事件的 action 1234567891011121314151617181920212223242526272829303132333435363738import React, { Component } from 'react';import { connect } from 'react-redux';import { HearderWrapper, SearchInput } from './style';//store的index.js中export { reducer, actionCreators }import { actionCreators } from './store';class Hearder extends Component { render() { const { focused, handlerInputFocus, handlerInputBlur } = this.props; return ( &lt;HearderWrapper&gt; //使用connect做了一个绑定 //这里的this.props.handlerInputFocus/focused就是mapDispatchToProps里的handlerInputFocus/focused &lt;SearchInput className={focused ? 'focus' : 'blur'} onFocus={handlerInputFocus}/&gt; &lt;/HearderWrapper&gt; ); }}const mapStateToProps = state =&gt; { return { focused: state.getIn(['header', 'focused']), };};const mapDispatchToProps = dispatch =&gt; { return { //发生事件时派发actionCreator handlerInputFocus() { dispatch(actionCreators.searchFocus()); } };};// 容器组件-负责处理数据逻辑export default connect( mapStateToProps, mapDispatchToProps)(Hearder);","link":"/2018/11/22/redux简易demo/"},{"title":"JS基础知识及常考面试题","text":"1. 数据类型 原始（Primitive）类型       面试题：原始类型有哪几种？null 是对象吗？        原始类型种类：boolean、number、string、null、undefined、symbol       原始类型存储的都是值，没有函数可以调用，true.toString()会强制转换成对象 String 类型       typof null 输出 object，但是是 JS 的一个 bug，最初设计使用 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象， null 表示全为 0，所以误判为 object。 对象（Object）类型       面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？        原始类型存储的是值，对象类型存储的是地址（指针）。当我们将变量赋值给另一个变量时，复制的是原本变量的地址（指针），所以数据修改时，是修改存放在该地址（指针）上的值，导致两个变量的值都发生了变化。       函数传参是传递对象指针的副本，形参会被重新分配一个新的地址（指针），就和原本的对象没有关系了，两个变量的值就不同。 类型判断       面试题：typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？        typeof 除了 null 之外都可以显示正确的类型，typeof null 为 object，typeof 除了函数的对象，都会显示 object，typeof 函数会显示 function，所以 typeof 不能准确判断变量的类型。       instanceof 是通过原型链来判断对象的正确类型的，但是不能直接通过 instanceof 来判断原始类型，但是可以通过 Symbol.hasInstance 来改造。 123456class PrimitiveString { static [Symbol.hasInstance](x) { return typeof x === &apos;string&apos; }}console.log(&apos;hello world&apos; instanceof PrimitiveString) // true 类型转换       原始类型之间转换：转换为布尔值、转换为数字、转换为字符串 注：在条件判断时，除了 undefined， null， false， NaN， ‘’， 0， -0，其他所有值都转为 true，包括所有对象。        对象转原始类型：会调用内置的 [[ToPrimitive]] 函数，该函数会优先调用 valueOf 方法，如果转换为基础类型就返回转换后的值，否则调用 toString 方法，如果两种方法都没有返回原始类型，则抛错。(可以重写 Symbol.toPrimitive 方法，该方法在转原始类型时调用的优先级最高)        toString()与 valueOf()的差别： toString()将数据转换成相应的字符串形式，参考类型转换表 valueOf()返回自身的值，比如数组会返回数组，函数会返回函数 2.四则运算符 加法运算符：       如果其中一方是字符串，就把另一方也转换为字符串，例： 11 + &apos;1&apos; -&gt; &apos;11&apos;        如果一方不是字符串或数字，就将它转换成数字或字符串，例： 12true + true -&gt; 24 + [1,2,3] -&gt; &apos;41,2,3&apos;        一元加法运算，快速获取 number 类型，例： 12+&apos;1&apos; -&gt; 1&apos;a&apos; + + &apos;b&apos; -&gt; &apos;aNaN&apos; 其他的运算符：       只要其中一方是数字，另一方就转为数字 注：如果{}被放在运算符最前面，会当做代码块处理,如果{}被放在运算中，那么他首先会调用 toString 方法 12{} + [] =&gt; 0[] + {} =&gt; &quot;[object Object]&quot; 3.比较运算符       如果是对象，通过 toPrimitive 转换对象，具体调用规则看上面的类型转换       如果是字符串，通过 unicode 字符索引来比较 4.this       面试题：如何正确判断 this？箭头函数的 this 是什么？        箭头函数没有 this，箭头函数中的 this 取决于包裹箭头函数的第一个普通函数的 this，就不能用过构造函数。       谁调用了函数，谁就是 this。多个 this 同时出现的情况下，this 的优先级：new foo() &gt; foo.bind() &gt; obj.foo() &gt; foo() 5.== 和 ===       面试题：==和===有什么区别？ == 类型不一样就会进行类型转换，相同就比大小。流程： 比对双方是否为 null 和 undefined，是则返回 true 比对双方类型是否为 string 和 number，是则将字符串转为 number，例： 11 == &apos;1&apos; -&gt; 1 == 1 比对一方是否为 boolean，是则把 boolean 转为 number，例： 1&apos;1&apos; == true -&gt; &apos;1&apos; == 1 判断一方是否为 object，另一方为 string、number、symbol，是则会 object 转为原始类型，例： 1&apos;1&apos; == { name:&apos;xx&apos; } -&gt; &apos;1&apos; == &apos;[object Object]&apos;        思考题： [] == ![] 123![].valueOf() -&gt; false[].valueOf() -&gt; [][] == false -&gt; true ===判断类型和值是否相同。 6. 闭包       面试题：什么是闭包？如何解决循环中 var 定义函数的问题？        定义：函数 A 的内部有一个函数 B，函数 B 可以访问函数 A 中的变量，函数 B 就是闭包。函数嵌套函数，返回一个函数，这个解释不完整，看下面的例子： 12345678function A() { let a = 1 window.B = function () { console.log(a) }}A()B() // 1        经典面试题： 12345for (var i = 1; i &lt;= 5; i++) { setTimeout(function timer() { console.log(i) }, i * 1000)}        输出全是 6 的原因：setTimeout 是个异步函数，所以 for 先全部执行完毕，再到 event loop 中执行 setTimeout，此时 i 已经是 6 了。解决方法： 方法 1：使用闭包，用立即执行函数包裹（关键！在 for 循环中定义了 5 个定时器，本来 5 个定时器会放到队列里等待执行，由于外面是立即执行函数，就会立即执行，并且把 i 传进去了，等到函数执行的时候，向上查找 i，正好在立即执行函数的作用域里找到了 i） 1234567for (var i = 1; i &lt;= 5; i++) { (function(j) { setTimeout(function timer() { console.log(j) }, j * 1000) })(i)} 1234567for (var i = 1; i &lt;= 5; i++) { setTimeout((function(i) { return function() { console.log(i); } })(i), i * 1000);} 方法 2：使用 setTimeout 的第三个参数，当做定时器函数的参数 123456789for (var i = 1; i &lt;= 5; i++) { setTimeout( function timer(j) { console.log(j) }, i \\* 1000, i )} 方法 3：使用 let 来定义 i 7. 深浅拷贝       面试题：什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？ 浅拷贝只拷贝对象的第一层，如果接下去的值还有对象，则需要使用深拷贝。 用 Object.assign 和展开运算符…解决浅拷贝的问题，拷贝所有的属性值到新对象 实现深拷贝：使用 JSON.parse(JSON.stringify(object))，但是会忽略 undefined、symbol，不能序列化函数，也不能解决循环引用的对象，所以推荐使用 lodash 的深拷贝函数 123456789101112131415161718function deepClone(obj) { function isObject(o) { return (typeof o === &apos;object&apos; || typeof o === &apos;function&apos;) &amp;&amp; o !== null } if (!isObject(obj)) { throw new Error(&apos;非对象&apos;) } let isArray = Array.isArray(obj) let newObj = isArray ? [...obj] : { ...obj } //Reflect.ownKeys返回所有属性key,Object.keys()返回属性key，但不包括方法属性 Reflect.ownKeys(newObj).forEach(key =&gt; { newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key] }) return newObj} 7. 原型       面试题：如何理解原型？如何理解原型链？        每个 JS 对象都有proto属性，这个属性实际上是个对象，这个属性指向原型，是为了让我们访问到内部属性 [[prototype]] 。原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型。       原型链就是多个对象通过proto的方式连接了起来，obj 可以访问 valueOf 就是因为 obj 通过原型链找到 Object，从而找到了 valueOf 函数，一个类型的原型对象等于另一个类型的实例，伪代码 Subtype.prototype = new SuperType()。 123456789__proto__ :{ constructor:{ //constructor指向下面的原型 prototype:{ //原型的constructor指向构造函数 constructor:{ //构造函数又通过prototype指向原型 prototype... //形成原型链 } } }}","link":"/2019/01/16/JS基础知识及常考面试题/"},{"title":"vue监听多个data值变化","text":"操作方法 使用 computed计算属性定义一个变量，用来返回多个 data 值 使用 watch侦听属性控制变量，当变量发生改变时，执行函数，并加上 deep:true 的选项参数，用于发现对象内部值的变化 代码演示使用场景，表单验证时，其中一个控件为空，则不允许点击提交按钮 12345678910111213141516171819202122computed: { allFormParam() { const { value1, value2, value3 } = this; return { value1, value2, value3 } }}，watch: { allFormParam: { handler(val) { let flag = false; for (const key in val) { if (val.hasOwnProperty(key) &amp;&amp; val[key] !== '') { flag = true; } } this.formBtnDisabled = flag; }, deep: true }}","link":"/2018/10/24/vue监听多个data值变化/"},{"title":"Event Loop","text":"1.进程与线程       面试题：进程与线程区别？JS 单线程带来的好处？ 进程：描述了 CPU 在运行指令及加载和保存上下文所需的时间 线程：是进程中的更小单位，描述了执行一段执行所需的时间        当在浏览器打开一个 Tab 页时，就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。        JS 单线程可以达到节省内存，节约上下文切换时间、没有锁的问题的好处。在 JS 运行时可能会阻止 UI 渲染，说明两个线程是互斥的，避免 JS 修改 DOM 的时候 UI 线程在工作就可能导致不能安全渲染 UI。 2.执行栈       面试题：什么是执行栈？        可以理解为是一个存储函数调用的栈结构，遵循先进后出的原则。        当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈。        当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现栈溢出的问题 3.浏览器中的 Event Loop       面试题：异步代码执行顺序？解释一下什么是 Event Loop ？        执行 JS 代码的时候其实就是往执行栈中放入函数，遇到异步代码时，会被挂起并在需要的时候加入到 Task 队列中。执行栈为空，Event Loop 就会从 Task 队列拿出需要执行的代码并放入执行栈中执行。 宏任务包括 ：script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。 微任务包括 ：process.nextTick ，promise ，MutationObserver。       例子： 123456789101112131415161718192021222324252627console.log(&apos;script start&apos;) // 1async function async1() { await async2() console.log(&apos;async1 end&apos;) // 5，相当于在Primise的then中}async function async2() { console.log(&apos;async2 end&apos;) // 2，返回一个Promise}async1()setTimeout(function() { console.log(&apos;setTimeout&apos;) // 8}, 0)new Promise(resolve =&gt; { console.log(&apos;Promise&apos;) // 3 resolve()}) .then(function() { console.log(&apos;promise1&apos;) // 6 }) .then(function() { console.log(&apos;promise2&apos;) // 7 })console.log(&apos;script end&apos;) // 4，同步执行完毕 所以 Event Loop 执行顺序如下所示： 首先执行同步代码，这属于宏任务 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行 执行所有微任务 当执行完所有微任务后，如有必要会渲染页面 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数","link":"/2019/01/22/Event Loop/"}],"tags":[{"name":"个人总结","slug":"个人总结","link":"/tags/个人总结/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"redux","slug":"redux","link":"/tags/redux/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[{"name":"年度总结","slug":"年度总结","link":"/categories/年度总结/"},{"name":"前端面试之道","slug":"前端面试之道","link":"/categories/前端面试之道/"},{"name":"tips","slug":"tips","link":"/categories/tips/"},{"name":"前端笔记","slug":"前端笔记","link":"/categories/前端笔记/"}]}