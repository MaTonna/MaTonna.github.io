<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浏览器缓存机制 · MaTonna's blog</title><meta name="description" content="浏览器缓存机制 - MaTonna"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="github.com/MaTonna/atom.xml" title="MaTonna's blog"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">MaTonna's blog</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><ul class="shortcut-icons"><a href="https://github.com/MaTonna" target="_blank"><img src="/images/github.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">浏览器缓存机制</h1><div class="post-info">Feb 12, 2019</div><div class="post-content"><p>&#160; &#160; &#160; &#160;缓存可以简单高效的优化性能，可以显著减少网络传输带来的损耗。浏览器缓存可以帮我们在数据请求中的网络请求和浏览器响应这两步优化性能，直接使用缓存而不发起请求，或者发起请求但是后端存储的数据和前端一致，就没有必要将数据返回回来，就减少了响应数据。</p>
<h3 id="1-缓存位置"><a href="#1-缓存位置" class="headerlink" title="1. 缓存位置"></a>1. 缓存位置</h3><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p>&#160; &#160; &#160; &#160;它是浏览器背后的独立线程，一般用来实现缓存功能。传输协议必须是 https，因为涉及到请求拦截，必须用 https 协议来保障安全。<br>&#160; &#160; &#160; &#160;实现缓存功能步骤：</p>
<ol>
<li>注册 Service Worker</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">'sw.js'</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'service worker 注册成功'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'servcie worker 注册失败'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>监听到 install 事件，缓存需要的文件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听 `install` 事件，回调中缓存所需文件</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, e =&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'my-cache'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([<span class="string">'./index.html'</span>, <span class="string">'./index.js'</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>下次用户访问就通过拦截请求查询是否存在缓存，存在则直接读取文件，否则就去请求数据</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截所有请求事件</span></span><br><span class="line"><span class="comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, e =&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'fetch source'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;在开发者工具中的 Application 可以看到 Service Worker 已经启动，Cache 中也可以看到我们缓存的文件。</p>
<h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>&#160; &#160; &#160; &#160;Memory Cache 是内存中的缓存，读取速度比磁盘快，但是缓存持续时间短，随着进程的释放而释放，一旦关闭 tab 页，内存中的缓存就会被释放。<br>&#160; &#160; &#160; &#160;但是不能让数据都存在内存中，计算机内存比硬盘容量小，大文件一般不存储在内存中，内存如果使用率高，文件会优先存储进硬盘。</p>
<h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p>&#160; &#160; &#160; &#160;Disk Cache 是存储在硬盘中的缓存，虽然速度较慢，但是比 Memory Cache 胜在容量和存储时效性上。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。即使跨站点，相同地址的资源一旦被硬盘缓存下来就不会重新请求数据。</p>
<h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><p>&#160; &#160; &#160; &#160;Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时才会使用，缓存时间短暂，只在 session 中，一旦 session 结束就会被释放。</p>
<h3 id="2-缓存策略"><a href="#2-缓存策略" class="headerlink" title="2. 缓存策略"></a>2. 缓存策略</h3><p>&#160; &#160; &#160; &#160;浏览器缓存策略分为强缓存和协商缓存两种，都是通过设置 HTTP Header 来实现的。</p>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>&#160; &#160; &#160; &#160;强缓存表示在缓存期间不需要请求，state code 为 200。</p>
<ol>
<li>设置 Expires</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Oct <span class="number">2018</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;表示会在特定的时间后过期，需要再次请求。但是 Expires 受限于本地时间，修改了本地时间可能会造成缓存失败。</p>
<ol start="2">
<li>设置 Cache-control</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-control: max-age=<span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;表示资源会在 30s 后过期，需要再次请求，优先级高于 Expires，可以在请求头或者响应头中设置，可以组合使用多种指令。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。<br><img src="/img/content/cache-control.png" alt="常见指令作用"></p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>&#160; &#160; &#160; &#160;协商缓存表示如果缓存过期了，需要发起请求验证资源是否有更新。当浏览器发起请求验证资源时，如果资源没有改变则返回 304，并且更新浏览器缓存有效期。</p>
<ol>
<li>设置 Last-Modified<br>&#160; &#160; &#160; &#160;Last-Modified 表示本地文件最后修改地址，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话则讲新的资源文件发送回来，否则返回 304。<br>&#160; &#160; &#160; &#160;但是如果本地打开了缓存文件，会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源。Last-Modified 以秒计时，如果在不可感知的时间内修改完文件，服务端则认为资源命中，不会返回正确的资源。</li>
<li>设置 ETag<br>&#160; &#160; &#160; &#160;ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问 ETag 是否改变，有变动就发送新资源回来，并且优先级高于 Last-Modified。</li>
</ol>
<p>&#160; &#160; &#160; &#160;<strong>如果没有设置任何缓存策略，浏览器会采用一个启发式的算法，通常取响应头中的 Date 减去 Last-Modified 值的 10%作为缓存时间。</strong><br>&#160; &#160; &#160; &#160;<strong>缓存的优先级：Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified</strong><br><img src="/img/content/cache-flow.png" alt="浏览器缓存机制流程图"></p>
<h3 id="实际场景应用缓存策略"><a href="#实际场景应用缓存策略" class="headerlink" title="实际场景应用缓存策略"></a>实际场景应用缓存策略</h3><h4 id="频繁变动的资源"><a href="#频繁变动的资源" class="headerlink" title="频繁变动的资源"></a>频繁变动的资源</h4><p>&#160; &#160; &#160; &#160;频繁变动的资源首先使用 Cache-Control: no-cache 使浏览器每次都请求服务器，再配合 ETag 或者 Last-Modified 来验证资源是否有效，可以减少响应数据的大小。</p>
<h4 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h4><p>&#160; &#160; &#160; &#160;可以用打包工具给文件名进行哈希处理，代码修改后才会生成新的文件名。然后就可以给代码文件设置一年的有效期 Cache-Control: max-age=3153600，这样就只有当 HTML 文件引入的文件名发生变化才会去下载最新的代码文件，否则就一直使用缓存。</p>
</div></article></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'matonna';
var disqus_identifier = '2019/02/12/浏览器缓存机制/';
var disqus_title = '浏览器缓存机制';
var disqus_url = 'github.com/MaTonna/2019/02/12/浏览器缓存机制/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//matonna.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/2019/02/18/小程序-基础/" class="prev">上一篇</a><a href="/2019/01/25/浏览器基础知识点及常考面试题/" class="next">下一篇</a></div><div class="copyright"><p>© 2018 - 2019 <a href="github.com/MaTonna">MaTonna</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"matonna",'auto');ga('send','pageview');</script></body></html>